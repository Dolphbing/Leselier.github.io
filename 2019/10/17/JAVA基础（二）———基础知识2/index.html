<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="JAVA,">










<meta name="description" content="二、JAVA基础知识4、集合类4.1 集合类的关系图谱Collection 和 Collections 首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Col">
<meta name="keywords" content="JAVA">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA基础（二）———基础知识2">
<meta property="og:url" content="https://Leselier.github.io/2019/10/17/JAVA基础（二）———基础知识2/index.html">
<meta property="og:site_name" content="Leselier&#39;s Blog">
<meta property="og:description" content="二、JAVA基础知识4、集合类4.1 集合类的关系图谱Collection 和 Collections 首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Col">
<meta property="og:locale" content="en">
<meta property="og:image" content="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg">
<meta property="og:image" content="http://www.hollischuang.com/wp-content/uploads/2016/03/java-collection-hierarchy.jpeg">
<meta property="og:image" content="http://www.hollischuang.com/wp-content/uploads/2016/03/MapClassHierarchy-600x354.jpg">
<meta property="og:image" content="http://www.hollischuang.com/wp-content/uploads/2016/03/collection-summary.png">
<meta property="og:image" content="https://camo.githubusercontent.com/245638178114b71fe0054245f8449c97752ff907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343037353231392e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/1872cc3bf10ab486bc728651f402137af6768bf3/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343535363438342e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/12a4a188624b105b44c05f82810020b6f81ea907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234323032353530362e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/59b30017b1c1cb6e224f2d4fb03d6c5bcac4a31f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343630363835312e6a7067">
<meta property="og:image" content="https://camo.githubusercontent.com/aff46cf678b76c862a8583d594844742597cde65/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234353436333732302e6a7067">
<meta property="og:updated_time" content="2019-10-18T02:11:42.719Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JAVA基础（二）———基础知识2">
<meta name="twitter:description" content="二、JAVA基础知识4、集合类4.1 集合类的关系图谱Collection 和 Collections 首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Col">
<meta name="twitter:image" content="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://Leselier.github.io/2019/10/17/JAVA基础（二）———基础知识2/">





  <title>JAVA基础（二）———基础知识2 | Leselier's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <a href="https://github.com/Leselier" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leselier's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/17/JAVA基础（二）———基础知识2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JAVA基础（二）———基础知识2</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-17T21:37:58+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="二、JAVA基础知识"><a href="#二、JAVA基础知识" class="headerlink" title="二、JAVA基础知识"></a>二、JAVA基础知识</h3><h4 id="4、集合类"><a href="#4、集合类" class="headerlink" title="4、集合类"></a>4、集合类</h4><h5 id="4-1-集合类的关系图谱"><a href="#4-1-集合类的关系图谱" class="headerlink" title="4.1 集合类的关系图谱"></a>4.1 集合类的关系图谱</h5><p><strong>Collection 和 Collections</strong></p>
<p>首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Collections是一个工具类，不能实例化）</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg" alt="CollectionVsCollections"></a></p>
<p><strong>Collection家族关系图</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/java-collection-hierarchy.jpeg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/java-collection-hierarchy.jpeg" alt="java-collection-hierarchy"></a></p>
<p><strong>Map家族的关系图</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/MapClassHierarchy-600x354.jpg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/MapClassHierarchy-600x354.jpg" alt="MapClassHierarchy-600x354"></a></p>
<p><strong>关系图谱</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/collection-summary.png" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/collection-summary.png" alt="collection-summary"></a></p>
<p><strong>代码示例</strong></p>
<p>下面是一个简单的例子来说明一些集合类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">a1.add(<span class="string">"Program"</span>);</span><br><span class="line">a1.add(<span class="string">"Creek"</span>);</span><br><span class="line">a1.add(<span class="string">"Java"</span>);</span><br><span class="line">a1.add(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"ArrayList Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + a1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">l1.add(<span class="string">"Program"</span>);</span><br><span class="line">l1.add(<span class="string">"Creek"</span>);</span><br><span class="line">l1.add(<span class="string">"Java"</span>);</span><br><span class="line">l1.add(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"LinkedList Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + l1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s1 = <span class="keyword">new</span> HashSet&lt;String&gt;(); <span class="comment">// or new TreeSet() will order the elements;</span></span><br><span class="line">s1.add(<span class="string">"Program"</span>);</span><br><span class="line">s1.add(<span class="string">"Creek"</span>);</span><br><span class="line">s1.add(<span class="string">"Java"</span>);</span><br><span class="line">s1.add(<span class="string">"Java"</span>);</span><br><span class="line">s1.add(<span class="string">"tutorial"</span>);</span><br><span class="line">System.out.println(<span class="string">"Set Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + s1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; m1 = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); <span class="comment">// or new TreeMap() will order based on keys</span></span><br><span class="line">m1.put(<span class="string">"Windows"</span>, <span class="string">"2000"</span>);</span><br><span class="line">m1.put(<span class="string">"Windows"</span>, <span class="string">"XP"</span>);</span><br><span class="line">m1.put(<span class="string">"Language"</span>, <span class="string">"Java"</span>);</span><br><span class="line">m1.put(<span class="string">"Website"</span>, <span class="string">"programcreek.com"</span>);</span><br><span class="line">System.out.println(<span class="string">"Map Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + m1);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList Elements</span><br><span class="line">    [Program, Creek, Java, Java]</span><br><span class="line">LinkedList Elements</span><br><span class="line">    [Program, Creek, Java, Java]</span><br><span class="line">Set Elements</span><br><span class="line">    [tutorial, Creek, Program, Java]</span><br><span class="line">Map Elements</span><br><span class="line">    &#123;Windows=XP, Website=programcreek.com, Language=Java&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-ArrayList和LinkedList和Vector的区别"><a href="#4-2-ArrayList和LinkedList和Vector的区别" class="headerlink" title="4.2 ArrayList和LinkedList和Vector的区别"></a>4.2 ArrayList和LinkedList和Vector的区别</h5><p>List主要有ArrayList、LinkedList与Vector几种实现。</p>
<p>这三者都实现了List 接口，使用方式也很相似,主要区别在于因为实现方式的不同,所以对不同的操作具有不同的效率。</p>
<p>ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组.</p>
<p>LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.</p>
<p>当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义.</p>
<p>Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。</p>
<p>Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.</p>
<p>而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.</p>
<p>注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。</p>
<h5 id="4-3-SynchronizedList和Vector的区别"><a href="#4-3-SynchronizedList和Vector的区别" class="headerlink" title="4.3 SynchronizedList和Vector的区别"></a>4.3 SynchronizedList和Vector的区别</h5><p>Vector是java.util包中的一个类。 SynchronizedList是java.util.Collections中的一个静态内部类。</p>
<p>在多线程的场景中可以直接使用Vector类，也可以使用Collections.synchronizedList(List list)方法来返回一个线程安全的List。</p>
<p><strong>那么，到底SynchronizedList和Vector有没有区别，为什么java api要提供这两种线程安全的List的实现方式呢？</strong></p>
<p>首先，我们知道Vector和Arraylist都是List的子类，他们底层的实现都是一样的。所以这里比较如下两个<code>list1</code>和<code>list2</code>的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List list2 =  Collections.synchronizedList(list);</span><br><span class="line">Vector&lt;String&gt; list1 = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>1)、比较几个重要的方法。</strong></p>
<p><strong>(1)add方法</strong></p>
<p><strong>Vector的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronizedList的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">       list.add(index, element);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，使用同步代码块的方式调用ArrayList的add()方法。ArrayList的add方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面两段代码中发现有两处不同： <strong>1.Vector使用同步方法实现，synchronizedList使用同步代码块实现。 2.两者的扩充数组容量方式不一样（两者的add方法在扩容方面的差别也就是ArrayList和Vector的差别。）</strong></p>
<p><strong>(2) remove方法</strong></p>
<p><strong>synchronizedList的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList类的remove方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Vector的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>从remove方法中我们发现除了一个使用同步方法，一个使用同步代码块之外几乎无任何区别。</strong></p>
<blockquote>
<p><strong>通过比较其他方法，我们发现，SynchronizedList里面实现的方法几乎都是使用同步代码块包上List的方法。如果该List是ArrayList,那么，SynchronizedList和Vector的一个比较明显区别就是一个使用了同步代码块，一个使用了同步方法。</strong></p>
</blockquote>
<p><strong>2)、区别分析</strong></p>
<p><strong>数据增长区别</strong></p>
<blockquote>
<p><strong>从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。</strong></p>
</blockquote>
<p><strong>同步代码块和同步方法的区别</strong> 1.同步代码块在锁定的范围上可能比同步方法要小，一般来说锁的范围大小和性能是成反比的。 2.同步块可以更加精确的控制锁的作用域（锁的作用域就是从锁被获取到其被释放的时间），同步方法的锁的作用域就是整个方法。 3.静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁。</p>
<blockquote>
<p><strong>因为SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。 在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象又是什么呢？ 其实SynchronizedList有一个构造函数可以传入一个Object,如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。</strong></p>
</blockquote>
<p>所以，SynchronizedList和Vector的区别目前为止有两点： 1.如果使用add方法，那么他们的扩容机制不一样。 2.SynchronizedList可以指定锁定的对象。</p>
<p>但是，凡事都有但是。 SynchronizedList中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。但是Vector却对该方法加了方法锁。 所以说，在使用SynchronizedList进行遍历的时候要手动加锁。</p>
<p>但是，但是之后还有但是。</p>
<p>之前的比较都是基于我们将ArrayList转成SynchronizedList。那么如果我们想把LinkedList变成线程安全的，或者说我想要方便在中间插入和删除的同步的链表，那么我可以将已有的LinkedList直接转成 SynchronizedList，而不用改变他的底层数据结构。而这一点是Vector无法做到的，因为他的底层结构就是使用数组实现的，这个是无法更改的。</p>
<p>所以，最后，SynchronizedList和Vector最主要的区别： <strong>1.SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</strong> <strong>2.使用SynchronizedList的时候，进行遍历时要手动进行同步处理</strong>。 <strong>3.SynchronizedList可以指定锁定的对象。</strong></p>
<h5 id="4-4-HashMap、HashTable、ConcurrentHashMap区别"><a href="#4-4-HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="4.4 HashMap、HashTable、ConcurrentHashMap区别"></a>4.4 HashMap、HashTable、ConcurrentHashMap区别</h5><p><strong>HashMap和HashTable有何不同？</strong></p>
<p>线程安全：</p>
<p>HashTable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用HashTable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<p>继承关系： HashTable是基于陈旧的Dictionary类继承来的。 HashMap继承的抽象类AbstractMap实现了Map接口。</p>
<p>允不允许null值： HashTable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。 HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p>
<p>默认初始容量和扩容机制： HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。原因参考全网把Map中的hash()分析的最透彻的文章，别无二家。-HollisChuang’s Blog</p>
<p>哈希值的使用不同 ： HashTable直接使用对象的hashCode。 HashMap重新计算hash值。</p>
<p>遍历方式的内部实现上不同 ： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 HashMap 实现 Iterator，支持fast-fail，Hashtable的 Iterator 遍历支持fast-fail，用 Enumeration 不支持 fast-fail</p>
<p><strong>HashMap 和 ConcurrentHashMap 的区别？</strong></p>
<p>ConcurrentHashMap和HashMap的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别，ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。</p>
<p>ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制。所以，前者线程安全的，后者不是线程安全的。</p>
<p>PS：以上区别基于jdk1.8以前的版本。</p>
<h5 id="4-5-List和Set区别"><a href="#4-5-List和Set区别" class="headerlink" title="4.5 List和Set区别"></a>4.5 List和Set区别</h5><p>List,Set都是继承自Collection接口。都是用来存储一组相同类型的元素的。</p>
<p>List特点：元素有放入顺序，元素可重复 。</p>
<p>有顺序，即先放入的元素排在前面。</p>
<p>Set特点：元素无放入顺序，元素不可重复。</p>
<p>无顺序，即先放入的元素不一定排在前面。 不可重复，即相同元素在set中只会保留一份。所以，有些场景下，set可以用来去重。 不过需要注意的是，set在元素插入时是要有一定的方法来判断元素是否重复的。这个方法很重要，决定了set中可以保存哪些元素。</p>
<h5 id="4-6-Set如何保证不重复的元素"><a href="#4-6-Set如何保证不重复的元素" class="headerlink" title="4.6 Set如何保证不重复的元素"></a>4.6 Set如何保证不重复的元素</h5><p>在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。</p>
<p>1、TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值 2、HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束</p>
<p>在HashSet中，基本的操作都是有HashMap底层实现的，因为HashSet底层是用HashMap存储数据的。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p>
<p>TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p>
<p>TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。TreeSet是用compareTo()来判断重复元素的。</p>
<h5 id="4-7-Java-8中stream相关方法"><a href="#4-7-Java-8中stream相关方法" class="headerlink" title="4.7 Java 8中stream相关方法"></a>4.7 Java 8中stream相关方法</h5><p>在Java中，集合和数组是我们经常会用到的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但是在Java 8之前，集合和数组的处理并不是很便捷。</p>
<p>不过，这一问题在Java 8中得到了改善，Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。本文就来介绍下如何使用Stream。特别说明一下，关于Stream的性能及原理不是本文的重点，如果大家感兴趣后面会出文章单独介绍。</p>
<p><strong>1）Stream介绍</strong></p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p>
<p>Stream有以下特性及优点：</p>
<ul>
<li>无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li>为函数式编程而生。对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li>
<li>惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>我们举一个例子，来看一下到底Stream可以做什么事情：</p>
<p>上面的例子中，获取一些带颜色塑料球作为数据源，首先过滤掉红色的、把它们融化成随机的三角形。再过滤器并删除小的三角形。最后计算出剩余图形的周长。</p>
<p>如上图，对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作(terminal operation)。</p>
<p><strong>2）Stream的创建</strong></p>
<p>在Java 8中，可以有多种方法来创建流。</p>
<p><strong>（1）、通过已有的集合来创建流</strong></p>
<p>在Java 8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了stream方法，可以将一个集合类转换成流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br></pre></td></tr></table></figure>
<p>以上，通过一个已有的List创建一个流。除此以外，还有一个parallelStream方法，可以为集合创建一个并行流。</p>
<p>这种通过集合创建出一个Stream的方式也是比较常用的一种方式。</p>
<p><strong>（2）、通过Stream创建流</strong></p>
<p>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br></pre></td></tr></table></figure>
<p>如以上代码，直接通过of方法，创建并返回一个Stream。</p>
<p><strong>2）Stream中间操作</strong></p>
<p>Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p>
<p><a href="https://camo.githubusercontent.com/245638178114b71fe0054245f8449c97752ff907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343037353231392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/245638178114b71fe0054245f8449c97752ff907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343037353231392e6a7067" alt="img"></a>￼</p>
<p>以下是常用的中间操作列表:</p>
<p><a href="https://camo.githubusercontent.com/1872cc3bf10ab486bc728651f402137af6768bf3/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343535363438342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1872cc3bf10ab486bc728651f402137af6768bf3/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343535363438342e6a7067" alt="img"></a>￼</p>
<p><strong>filter</strong></p>
<p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤掉空字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">""</span>, <span class="string">"HollisChuang"</span>, <span class="string">"H"</span>, <span class="string">"hollis"</span>);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//Hollis, , HollisChuang, H, hollis</span></span><br></pre></td></tr></table></figure>
<p><strong>map</strong></p>
<p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure>
<p><strong>limit/skip</strong></p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保理4个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure>
<p><strong>sorted</strong></p>
<p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure>
<p><strong>distinct</strong></p>
<p>distinct主要用来去重，以下代码片段使用 distinct 对元素进行去重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure>
<p>接下来我们通过一个例子和一张图，来演示下，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会发生什么。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">Stream s = strings.stream().filter(string -&gt; string.length()&lt;= <span class="number">6</span>).map(String::length).sorted().limit(<span class="number">3</span>)</span><br><span class="line">            .distinct();</span><br></pre></td></tr></table></figure>
<p>过程及每一步得到的结果如下图：</p>
<p><a href="https://camo.githubusercontent.com/12a4a188624b105b44c05f82810020b6f81ea907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234323032353530362e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/12a4a188624b105b44c05f82810020b6f81ea907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234323032353530362e6a7067" alt="img"></a>￼</p>
<p><strong>3）Stream最终操作</strong></p>
<p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就需要最终操作（terminal operation）</p>
<p>最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>
<p>俗话说，“你永远不会两次踏入同一条河”也正是这个意思。</p>
<p>常用的最终操作如下图：</p>
<p><a href="https://camo.githubusercontent.com/59b30017b1c1cb6e224f2d4fb03d6c5bcac4a31f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343630363835312e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/59b30017b1c1cb6e224f2d4fb03d6c5bcac4a31f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343630363835312e6a7067" alt="img"></a>￼</p>
<p><strong>forEach</strong></p>
<p>Stream 提供了方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>count</strong></p>
<p>count用来统计流中的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>,<span class="string">"Hollis666"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p><strong>collect</strong></p>
<p>collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>,<span class="string">"Hollis666"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">strings  = strings.stream().filter(string -&gt; string.startsWith(<span class="string">"Hollis"</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(strings);</span><br><span class="line"><span class="comment">//Hollis, HollisChuang, Hollis666, Hollis</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们还是使用一张图，来演示下，前文的例子中，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会，在分别使用不同的最终操作可以得到怎样的结果：</p>
<p>下图，展示了文中介绍的所有操作的位置、输入、输出以及使用一个案例展示了其结果。 <a href="https://camo.githubusercontent.com/aff46cf678b76c862a8583d594844742597cde65/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234353436333732302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/aff46cf678b76c862a8583d594844742597cde65/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234353436333732302e6a7067" alt="img"></a>￼</p>
<p><strong>总结</strong></p>
<p>本文介绍了Java 8中的Stream 的用途，优点等。还接受了Stream的几种用法，分别是Stream创建、中间操作和最终操作。</p>
<p>Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。</p>
<p>Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。</p>
<p>Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流装换成集合、以及元素的遍历等。</p>
<p><strong>4.8 apache集合处理工具类的使用</strong></p>
<p>平常我们在日常的开发中会一些通用的功能封装成一些工具类，以便之后复用。但是有些常用功能，业界已经存在，我们无需造轮子，只需直接使用或借用它们的 Api ，构建我们的自己项目中工具类。这篇首先介绍平常用到的 Apache 工具全家桶。</p>
<ul>
<li>commons-lang3</li>
<li>commons-io</li>
<li>commons-collections</li>
</ul>
<p><strong>commons-lang3</strong></p>
<blockquote>
<p><strong>The standard Java libraries fail to provide enough methods for manipulation of its core classes. Apache Commons Lang provides these extra methods.</strong></p>
</blockquote>
<p>正如 Apache 官方介绍，这个包主要扩展 java.lang 下核心类的方法，提供工具类方便我们平常 java.lang 下面的类，如 String , Date。以下介绍其常用的方法。</p>
<p><strong>StringUtils</strong></p>
<p>字符串相关操作，扩展 String 相关方法，可以使我们方便处理字符串，满足我们的日常使用。</p>
<p>StringUtils.isBlank || StringUtils.isEmpty 判断字符串是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两者都可以用于判断字符串是为空 isBlank 主要用于判断空白字符串 空字符("") 以及Null 而 isEmpty 主要用于判断空字符("")以及Null</span></span><br><span class="line">StringUtils.isBlank(<span class="string">" "</span>)       = <span class="keyword">true</span> </span><br><span class="line">StringUtils.isEmpty(<span class="string">" "</span>)       = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.countMatches 用于计数匹配上字符的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.countMatches(<span class="string">"abba"</span>, <span class="string">"a"</span>)   = <span class="number">2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>StringUtils.defaultIfEmpty 用于当字符串为空时，设置默认字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;</span><br></pre></td></tr></table></figure>
<p>StringUtils.equalsIgnoreCase  StringUtils.equals 用于判断字符串是否相等，前者忽略大小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.equals(<span class="string">"abc"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.equalsIgnoreCase(<span class="string">"abc"</span>, <span class="string">"ABC"</span>) = <span class="keyword">true</span></span><br><span class="line"><span class="comment">// 推荐使用该方法比较字符串，如果使用 a.equals(b),必须确保 a!=null</span></span><br><span class="line">StringUtils.equals(<span class="keyword">null</span>, <span class="string">"abc"</span>)  = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.join 字符串连接函数，可以将字符串数组或集合，按照指定字符连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 碰到这种需要固定分隔符拼接的情况，可以使用该函数，以免我们写一大串函数循环拼接</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">';'</span>)  = <span class="string">"a;b;c"</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.split 说完拼接，必定会有按照固定分隔符拆分的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split 分隔后会忽略为空的字符 如果不能忽略的话 使用 splitPreserveAllTokens</span></span><br><span class="line">StringUtils.split(<span class="string">"ab::ef"</span>, <span class="string">":"</span>) = [<span class="string">"ab"</span>, <span class="string">"ef"</span>]</span><br><span class="line">StringUtils.splitPreserveAllTokens(<span class="string">"ab::ef"</span>,<span class="string">":"</span>)=[<span class="string">"ab"</span>, <span class="string">""</span>, <span class="string">"ef"</span>]</span><br></pre></td></tr></table></figure>
<p><strong>ArrayUtils</strong></p>
<p>由于平常工作中习惯用集合代替数组对象，所以没有经常使用该类。</p>
<p>ArrayUtils.isEmpty 判断数组是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">ArrayUtils.isEmpty(a)=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>DateFormatUtils</strong></p>
<p>将时间按照指定格式输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line"><span class="comment">//2018-05-27 16:32:51</span></span><br></pre></td></tr></table></figure>
<p><strong>DateUtils</strong></p>
<p>该类可以将时间按照格式解析成 Date 类型，还可以用于时间计算</p>
<p>DateUtils.parseDate 按照格式转化成 Date 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) <span class="comment">// 将字符串转化成 Date 对象</span></span><br></pre></td></tr></table></figure>
<p>DateUtils.addDays addHours addMinutes 用于在指定 Date 加上相应时间，如想获取当前时间20天后的日期，就就可以使用 DateUtils.addDays。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">DateUtils.addDays(date,<span class="number">1</span>);<span class="comment">// date 为：2018-05-28 16:32:51</span></span><br><span class="line">DateUtils.addHours(date,<span class="number">1</span>)<span class="comment">// date 为：2018-05-28 17:32:51</span></span><br></pre></td></tr></table></figure>
<p>DateUtils.truncate 按照指定时间类型截断时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">DateUtils.truncate(date, Calendar.DATE);<span class="comment">// 2018-05-27 00:00:00</span></span><br><span class="line">DateUtils.truncate(date, Calendar.HOUR);<span class="comment">// 2018-05-27 16:00:00</span></span><br><span class="line"><span class="comment">// 如果按照 Date 截断时间，那么 Date 后面小时，分钟等全部置为0，相当于舍弃了 Date 之后的时间。</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>commons-io</strong></p>
<blockquote>
<p><strong>Commons IO is a library of utilities to assist with developing IO functionality.</strong></p>
</blockquote>
<p>主要包含一些 IO 相关的工具类,可以简化处理文件相关操作</p>
<p><strong>FileUtils</strong></p>
<p>文件操作相关工具类</p>
<p>FileUtils.copyDirectory || FileUtils.copyFile 拷贝文件夹或文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝文件</span></span><br><span class="line">File fileA = <span class="keyword">new</span> File(<span class="string">"E:\\test\\test.txt"</span>);</span><br><span class="line">File fileB = <span class="keyword">new</span> File(<span class="string">"E:\\test1\\test.txt"</span>);</span><br><span class="line">FileUtils.copyFile(fileA,fileB);</span><br></pre></td></tr></table></figure>
<p>FileUtils.listFiles 获取指定文件夹上所有文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照指定文件后缀如java,txt等去查找指定文件夹的文件</span></span><br><span class="line">File directory = <span class="keyword">new</span> File(<span class="string">"E:\\test"</span>);</span><br><span class="line">FileUtils.listFiles(directory, <span class="keyword">new</span> String[]&#123;<span class="string">"txt"</span>&#125;, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>FileUtils.readLines 读取文件所有行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取指定文件所有行 不需要使用 while 循环读取流了</span></span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(fileA)</span><br></pre></td></tr></table></figure>
<p>FileUtils.writeLines 有读就存在写，该方法可以一行行写入文本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以一行行写入文本</span></span><br><span class="line">List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">.....</span><br><span class="line">FileUtils.writeLines(lines)</span><br></pre></td></tr></table></figure>
<p><strong>IOUtils</strong></p>
<p>Io 操作相关，FileUtils 很多方法底层调用的是该类的方法</p>
<p>IOUtils.toString 将输入流转化为指定编码格式的字符串，该方法非常使用与 http 异步回调的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 http 异步回调的报文</span></span><br><span class="line">String resMsg = IOUtils.toString(request.getInputStream());</span><br></pre></td></tr></table></figure>
<p>IOUtils.toByteArray 将输入流转化为 byte 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 http 异步回调的报文</span></span><br><span class="line"><span class="keyword">byte</span>[] b = IOUtils.toByteArray(request.getInputStream());</span><br></pre></td></tr></table></figure>
<p>IOUtils.closeQuietly 关闭流，不需要在关闭前写判断和try-catch语句，commons-io 2.6 该方法已被 <strong>Deprecated</strong> ， 官方推荐使用 JDK7 try-with-resources 关闭。<strong>注：</strong> <em>该方法如果在输入流等 close 时，若产生 Exception ，异常将会被该方法吞掉。</em></p>
<p><strong>FilenameUtils</strong></p>
<p>在处理一些文件路径问题时，如果我们代码开发在 Windows 平台，部署却是在 Linux 平台，这个时候我们必须考虑平台分隔符问题。FilenameUtils 解决了平台问题，不用担心平台系统问题，导致的bug。</p>
<p>FilenameUtils.getBaseName 获取文件名字，去除前缀加扩展名 FilenameUtils.getExtension 获取文件扩展名，去除路径以及文件名 FilenameUtils.getName 获取文件全名，去除路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FilenameUtils.getBaseName(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">//test</span></span><br><span class="line">FilenameUtils.getExtension(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">//txt</span></span><br><span class="line">FilenameUtils.getName(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">// test.txt</span></span><br></pre></td></tr></table></figure>
<p>FilenameUtils.concat 文件路径拼接，不用担心文件的分隔符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilenameUtils.concat(<span class="string">"E:\\test"</span>, <span class="string">"test.txt"</span>);<span class="comment">//E:\test\test.txt</span></span><br></pre></td></tr></table></figure>
<p><strong>commons-collections</strong></p>
<blockquote>
<p><strong>The Java Collections Framework was a major addition in JDK 1.2. It added many powerful data structures that accelerate development of most significant Java applications. Since that time it has become the recognised standard for collection handling in Java</strong></p>
</blockquote>
<p>commons-collections 主要增强 java Collections 功能</p>
<p><strong>CollectionUtils</strong></p>
<p>为 Collection 实例提供工具方法</p>
<p>CollectionUtils.addAll 可以将数组，集合加入到指定集合，解决需要将数组加入到集合中情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">listA.add(<span class="string">"1"</span>);</span><br><span class="line">listA.add(<span class="string">"2"</span>);</span><br><span class="line">listA.add(<span class="string">"3"</span>);</span><br><span class="line">String[] arrays = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">CollectionUtils.addAll(listA, arrays);</span><br></pre></td></tr></table></figure>
<p>CollectionUtils.isEmpty CollectionUtils.isNotEmpty 快捷判断集合是否为空</p>
<h5 id="4-9-Collection和Collections区别"><a href="#4-9-Collection和Collections区别" class="headerlink" title="4.9 Collection和Collections区别"></a>4.9 Collection和Collections区别</h5><p>Collection 是一个集合接口。 它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。是list，set等的父接口。</p>
<p>Collections 是一个包装类。 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>日常开发中，不仅要了解Java中的Collection及其子类的用法，还要了解Collections用法。可以提升很多处理集合类的效率。</p>
<h5 id="4-10-Arrays-asList获得的List使用时需要注意什么"><a href="#4-10-Arrays-asList获得的List使用时需要注意什么" class="headerlink" title="4.10 Arrays.asList获得的List使用时需要注意什么"></a>4.10 Arrays.asList获得的List使用时需要注意什么</h5><ol>
<li>asList 得到的只是一个 Arrays 的内部类，一个原来数组的视图 List，因此如果对它进行增删操作会报错</li>
<li>用 ArrayList 的构造器可以将其转变成真正的 ArrayList</li>
</ol>
<h5 id="4-11-Enumeration和Iterator区别"><a href="#4-11-Enumeration和Iterator区别" class="headerlink" title="4.11 Enumeration和Iterator区别"></a>4.11 Enumeration和Iterator区别</h5><p>函数接口不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enumeration只有<span class="number">2</span>个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。</span><br><span class="line">Iterator只有<span class="number">3</span>个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</span><br></pre></td></tr></table></figure>
<p>Iterator支持fail-fast机制，而Enumeration不支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enumeration 是JDK <span class="number">1.0</span>添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK <span class="number">1.0</span>中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。</span><br><span class="line">而Iterator 是JDK <span class="number">1.2</span>才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</span><br></pre></td></tr></table></figure>
<p>注意：Enumeration迭代器只能遍历Vector、Hashtable这种古老的集合，因此通常不要使用它，除非在某些极端情况下，不得不使用Enumeration，否则都应该选择Iterator迭代器。</p>
<h5 id="4-12-CopyOnWriteArrayList"><a href="#4-12-CopyOnWriteArrayList" class="headerlink" title="4.12 CopyOnWriteArrayList"></a>4.12 CopyOnWriteArrayList</h5><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p>CopyOnWriteArrayList相当于线程安全的ArrayList，CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素add到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<p>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>注意：CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的。也就是说add方法是线程安全的。</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>
<p>和ArrayList不同的是，它具有以下特性：</p>
<p>支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照</p>
<h5 id="4-13-ConcurrentSkipListMap"><a href="#4-13-ConcurrentSkipListMap" class="headerlink" title="4.13 ConcurrentSkipListMap"></a>4.13 ConcurrentSkipListMap</h5><p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map，是线程安全的。一般很少会被用到，也是一个比较偏门的数据结构。</p>
<p>简单介绍下跳表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</span><br><span class="line"></span><br><span class="line">在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点。如图<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">跳表可以解决这种查询时间过长，其元素遍历的图示如图<span class="number">2</span>，跳表是一种使用”空间换时间”的概念用来提高查询效率的链表。</span><br></pre></td></tr></table></figure>
<p>ConcurrentSkipListMap 和 ConcurrentHashMap 的主要区别： a.底层实现方式不同。ConcurrentSkipListMap底层基于跳表。ConcurrentHashMap底层基于Hash桶和红黑树。 b.ConcurrentHashMap不支持排序。ConcurrentSkipListMap支持排序。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/JAVA/" rel="tag"># JAVA</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/16/JAVA基础篇（二）————基础知识/" rel="next" title="JAVA基础篇（二）————基础知识">
                <i class="fa fa-chevron-left"></i> JAVA基础篇（二）————基础知识
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/10/18/算法模板/" rel="prev" title="算法模板">
                算法模板 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/abc.JPG" alt="Leselier">
            
              <p class="site-author-name" itemprop="name">Leselier</p>
              <p class="site-description motion-element" itemprop="description">A master student of JUN</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">40</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Leselier" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5708446219/home" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#二、JAVA基础知识"><span class="nav-number">1.</span> <span class="nav-text">二、JAVA基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4、集合类"><span class="nav-number">1.1.</span> <span class="nav-text">4、集合类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-1-集合类的关系图谱"><span class="nav-number">1.1.1.</span> <span class="nav-text">4.1 集合类的关系图谱</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-2-ArrayList和LinkedList和Vector的区别"><span class="nav-number">1.1.2.</span> <span class="nav-text">4.2 ArrayList和LinkedList和Vector的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-3-SynchronizedList和Vector的区别"><span class="nav-number">1.1.3.</span> <span class="nav-text">4.3 SynchronizedList和Vector的区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-HashMap、HashTable、ConcurrentHashMap区别"><span class="nav-number">1.1.4.</span> <span class="nav-text">4.4 HashMap、HashTable、ConcurrentHashMap区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-5-List和Set区别"><span class="nav-number">1.1.5.</span> <span class="nav-text">4.5 List和Set区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-6-Set如何保证不重复的元素"><span class="nav-number">1.1.6.</span> <span class="nav-text">4.6 Set如何保证不重复的元素</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-7-Java-8中stream相关方法"><span class="nav-number">1.1.7.</span> <span class="nav-text">4.7 Java 8中stream相关方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-9-Collection和Collections区别"><span class="nav-number">1.1.8.</span> <span class="nav-text">4.9 Collection和Collections区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-10-Arrays-asList获得的List使用时需要注意什么"><span class="nav-number">1.1.9.</span> <span class="nav-text">4.10 Arrays.asList获得的List使用时需要注意什么</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-11-Enumeration和Iterator区别"><span class="nav-number">1.1.10.</span> <span class="nav-text">4.11 Enumeration和Iterator区别</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-12-CopyOnWriteArrayList"><span class="nav-number">1.1.11.</span> <span class="nav-text">4.12 CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-13-ConcurrentSkipListMap"><span class="nav-number">1.1.12.</span> <span class="nav-text">4.13 ConcurrentSkipListMap</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leselier</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
