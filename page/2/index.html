<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico?v=5.1.4">


  <link rel="mask-icon" href="/favicon.ico?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="A master student of JUN">
<meta name="keywords" content="二进制">
<meta property="og:type" content="website">
<meta property="og:title" content="Leselier&#39;s Blog">
<meta property="og:url" content="https://Leselier.github.io/page/2/index.html">
<meta property="og:site_name" content="Leselier&#39;s Blog">
<meta property="og:description" content="A master student of JUN">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Leselier&#39;s Blog">
<meta name="twitter:description" content="A master student of JUN">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://Leselier.github.io/page/2/">





  <title>Leselier's Blog</title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <a href="https://github.com/Leselier" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Leselier's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/17/JAVA基础（二）———基础知识2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/17/JAVA基础（二）———基础知识2/" itemprop="url">JAVA基础（二）———基础知识2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-17T21:37:58+08:00">
                2019-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="二、JAVA基础知识"><a href="#二、JAVA基础知识" class="headerlink" title="二、JAVA基础知识"></a>二、JAVA基础知识</h3><h4 id="4、集合类"><a href="#4、集合类" class="headerlink" title="4、集合类"></a>4、集合类</h4><h5 id="4-1-集合类的关系图谱"><a href="#4-1-集合类的关系图谱" class="headerlink" title="4.1 集合类的关系图谱"></a>4.1 集合类的关系图谱</h5><p><strong>Collection 和 Collections</strong></p>
<p>首先要明确的是，Collection 和 Collections是两个不同的概念。Collection是一个接口，所有的集合类（除Map外）都要继承（实现）自该接口。它提供了对集合对象进行基本操作的通用接口方法。Collections是一个包装类，它包含有各种有关集合操作的静态多态方法。（Collections是一个工具类，不能实例化）</p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/CollectionVsCollections.jpeg" alt="CollectionVsCollections"></a></p>
<p><strong>Collection家族关系图</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/java-collection-hierarchy.jpeg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/java-collection-hierarchy.jpeg" alt="java-collection-hierarchy"></a></p>
<p><strong>Map家族的关系图</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/MapClassHierarchy-600x354.jpg" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/MapClassHierarchy-600x354.jpg" alt="MapClassHierarchy-600x354"></a></p>
<p><strong>关系图谱</strong></p>
<p><a href="http://www.hollischuang.com/wp-content/uploads/2016/03/collection-summary.png" target="_blank" rel="noopener"><img src="http://www.hollischuang.com/wp-content/uploads/2016/03/collection-summary.png" alt="collection-summary"></a></p>
<p><strong>代码示例</strong></p>
<p>下面是一个简单的例子来说明一些集合类型:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; a1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">a1.add(<span class="string">"Program"</span>);</span><br><span class="line">a1.add(<span class="string">"Creek"</span>);</span><br><span class="line">a1.add(<span class="string">"Java"</span>);</span><br><span class="line">a1.add(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"ArrayList Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + a1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; l1 = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">l1.add(<span class="string">"Program"</span>);</span><br><span class="line">l1.add(<span class="string">"Creek"</span>);</span><br><span class="line">l1.add(<span class="string">"Java"</span>);</span><br><span class="line">l1.add(<span class="string">"Java"</span>);</span><br><span class="line">System.out.println(<span class="string">"LinkedList Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + l1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">Set&lt;String&gt; s1 = <span class="keyword">new</span> HashSet&lt;String&gt;(); <span class="comment">// or new TreeSet() will order the elements;</span></span><br><span class="line">s1.add(<span class="string">"Program"</span>);</span><br><span class="line">s1.add(<span class="string">"Creek"</span>);</span><br><span class="line">s1.add(<span class="string">"Java"</span>);</span><br><span class="line">s1.add(<span class="string">"Java"</span>);</span><br><span class="line">s1.add(<span class="string">"tutorial"</span>);</span><br><span class="line">System.out.println(<span class="string">"Set Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + s1 + <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; m1 = <span class="keyword">new</span> HashMap&lt;String, String&gt;(); <span class="comment">// or new TreeMap() will order based on keys</span></span><br><span class="line">m1.put(<span class="string">"Windows"</span>, <span class="string">"2000"</span>);</span><br><span class="line">m1.put(<span class="string">"Windows"</span>, <span class="string">"XP"</span>);</span><br><span class="line">m1.put(<span class="string">"Language"</span>, <span class="string">"Java"</span>);</span><br><span class="line">m1.put(<span class="string">"Website"</span>, <span class="string">"programcreek.com"</span>);</span><br><span class="line">System.out.println(<span class="string">"Map Elements"</span>);</span><br><span class="line">System.out.print(<span class="string">"\t"</span> + m1);</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ArrayList Elements</span><br><span class="line">    [Program, Creek, Java, Java]</span><br><span class="line">LinkedList Elements</span><br><span class="line">    [Program, Creek, Java, Java]</span><br><span class="line">Set Elements</span><br><span class="line">    [tutorial, Creek, Program, Java]</span><br><span class="line">Map Elements</span><br><span class="line">    &#123;Windows=XP, Website=programcreek.com, Language=Java&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-2-ArrayList和LinkedList和Vector的区别"><a href="#4-2-ArrayList和LinkedList和Vector的区别" class="headerlink" title="4.2 ArrayList和LinkedList和Vector的区别"></a>4.2 ArrayList和LinkedList和Vector的区别</h5><p>List主要有ArrayList、LinkedList与Vector几种实现。</p>
<p>这三者都实现了List 接口，使用方式也很相似,主要区别在于因为实现方式的不同,所以对不同的操作具有不同的效率。</p>
<p>ArrayList 是一个可改变大小的数组.当更多的元素加入到ArrayList中时,其大小将会动态地增长.内部的元素可以直接通过get与set方法进行访问,因为ArrayList本质上就是一个数组.</p>
<p>LinkedList 是一个双链表,在添加和删除元素时具有比ArrayList更好的性能.但在get与set方面弱于ArrayList.</p>
<p>当然,这些对比都是指数据量很大或者操作很频繁的情况下的对比,如果数据和运算量很小,那么对比将失去意义.</p>
<p>Vector 和ArrayList类似,但属于强同步类。如果你的程序本身是线程安全的(thread-safe,没有在多个线程之间共享同一个集合/对象),那么使用ArrayList是更好的选择。</p>
<p>Vector和ArrayList在更多元素添加进来时会请求更大的空间。Vector每次请求其大小的双倍空间，而ArrayList每次对size增长50%.</p>
<p>而 LinkedList 还实现了 Queue 接口,该接口比List提供了更多的方法,包括 offer(),peek(),poll()等.</p>
<p>注意: 默认情况下ArrayList的初始容量非常小,所以如果可以预估数据量的话,分配一个较大的初始值属于最佳实践,这样可以减少调整大小的开销。</p>
<h5 id="4-3-SynchronizedList和Vector的区别"><a href="#4-3-SynchronizedList和Vector的区别" class="headerlink" title="4.3 SynchronizedList和Vector的区别"></a>4.3 SynchronizedList和Vector的区别</h5><p>Vector是java.util包中的一个类。 SynchronizedList是java.util.Collections中的一个静态内部类。</p>
<p>在多线程的场景中可以直接使用Vector类，也可以使用Collections.synchronizedList(List list)方法来返回一个线程安全的List。</p>
<p><strong>那么，到底SynchronizedList和Vector有没有区别，为什么java api要提供这两种线程安全的List的实现方式呢？</strong></p>
<p>首先，我们知道Vector和Arraylist都是List的子类，他们底层的实现都是一样的。所以这里比较如下两个<code>list1</code>和<code>list2</code>的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List list2 =  Collections.synchronizedList(list);</span><br><span class="line">Vector&lt;String&gt; list1 = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>1)、比较几个重要的方法。</strong></p>
<p><strong>(1)add方法</strong></p>
<p><strong>Vector的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    insertElementAt(element, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insertElementAt</span><span class="params">(E obj, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; elementCount) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index</span><br><span class="line">                                                 + <span class="string">" &gt; "</span> + elementCount);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureCapacityHelper(elementCount + <span class="number">1</span>);</span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, elementCount - index);</span><br><span class="line">    elementData[index] = obj;</span><br><span class="line">    elementCount++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityHelper</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronizedList的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">synchronized</span> (mutex) &#123;</span><br><span class="line">       list.add(index, element);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，使用同步代码块的方式调用ArrayList的add()方法。ArrayList的add方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面两段代码中发现有两处不同： <strong>1.Vector使用同步方法实现，synchronizedList使用同步代码块实现。 2.两者的扩充数组容量方式不一样（两者的add方法在扩容方面的差别也就是ArrayList和Vector的差别。）</strong></p>
<p><strong>(2) remove方法</strong></p>
<p><strong>synchronizedList的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ArrayList类的remove方法内容如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Vector的实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= elementCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(index);</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = elementCount - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--elementCount] = <span class="keyword">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>从remove方法中我们发现除了一个使用同步方法，一个使用同步代码块之外几乎无任何区别。</strong></p>
<blockquote>
<p><strong>通过比较其他方法，我们发现，SynchronizedList里面实现的方法几乎都是使用同步代码块包上List的方法。如果该List是ArrayList,那么，SynchronizedList和Vector的一个比较明显区别就是一个使用了同步代码块，一个使用了同步方法。</strong></p>
</blockquote>
<p><strong>2)、区别分析</strong></p>
<p><strong>数据增长区别</strong></p>
<blockquote>
<p><strong>从内部实现机制来讲ArrayList和Vector都是使用数组(Array)来控制集合中的对象。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。</strong></p>
</blockquote>
<p><strong>同步代码块和同步方法的区别</strong> 1.同步代码块在锁定的范围上可能比同步方法要小，一般来说锁的范围大小和性能是成反比的。 2.同步块可以更加精确的控制锁的作用域（锁的作用域就是从锁被获取到其被释放的时间），同步方法的锁的作用域就是整个方法。 3.静态代码块可以选择对哪个对象加锁，但是静态方法只能给this对象加锁。</p>
<blockquote>
<p><strong>因为SynchronizedList只是使用同步代码块包裹了ArrayList的方法，而ArrayList和Vector中同名方法的方法体内容并无太大差异，所以在锁定范围和锁的作用域上两者并无却别。 在锁定的对象区别上，SynchronizedList的同步代码块锁定的是mutex对象，Vector锁定的是this对象。那么mutex对象又是什么呢？ 其实SynchronizedList有一个构造函数可以传入一个Object,如果在调用的时候显示的传入一个对象，那么锁定的就是用户传入的对象。如果没有指定，那么锁定的也是this对象。</strong></p>
</blockquote>
<p>所以，SynchronizedList和Vector的区别目前为止有两点： 1.如果使用add方法，那么他们的扩容机制不一样。 2.SynchronizedList可以指定锁定的对象。</p>
<p>但是，凡事都有但是。 SynchronizedList中实现的类并没有都使用synchronized同步代码块。其中有listIterator和listIterator(int index)并没有做同步处理。但是Vector却对该方法加了方法锁。 所以说，在使用SynchronizedList进行遍历的时候要手动加锁。</p>
<p>但是，但是之后还有但是。</p>
<p>之前的比较都是基于我们将ArrayList转成SynchronizedList。那么如果我们想把LinkedList变成线程安全的，或者说我想要方便在中间插入和删除的同步的链表，那么我可以将已有的LinkedList直接转成 SynchronizedList，而不用改变他的底层数据结构。而这一点是Vector无法做到的，因为他的底层结构就是使用数组实现的，这个是无法更改的。</p>
<p>所以，最后，SynchronizedList和Vector最主要的区别： <strong>1.SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</strong> <strong>2.使用SynchronizedList的时候，进行遍历时要手动进行同步处理</strong>。 <strong>3.SynchronizedList可以指定锁定的对象。</strong></p>
<h5 id="4-4-HashMap、HashTable、ConcurrentHashMap区别"><a href="#4-4-HashMap、HashTable、ConcurrentHashMap区别" class="headerlink" title="4.4 HashMap、HashTable、ConcurrentHashMap区别"></a>4.4 HashMap、HashTable、ConcurrentHashMap区别</h5><p><strong>HashMap和HashTable有何不同？</strong></p>
<p>线程安全：</p>
<p>HashTable 中的方法是同步的，而HashMap中的方法在默认情况下是非同步的。在多线程并发的环境下，可以直接使用HashTable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<p>继承关系： HashTable是基于陈旧的Dictionary类继承来的。 HashMap继承的抽象类AbstractMap实现了Map接口。</p>
<p>允不允许null值： HashTable中，key和value都不允许出现null值，否则会抛出NullPointerException异常。 HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。</p>
<p>默认初始容量和扩容机制： HashTable中的hash数组初始大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。原因参考全网把Map中的hash()分析的最透彻的文章，别无二家。-HollisChuang’s Blog</p>
<p>哈希值的使用不同 ： HashTable直接使用对象的hashCode。 HashMap重新计算hash值。</p>
<p>遍历方式的内部实现上不同 ： Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。 HashMap 实现 Iterator，支持fast-fail，Hashtable的 Iterator 遍历支持fast-fail，用 Enumeration 不支持 fast-fail</p>
<p><strong>HashMap 和 ConcurrentHashMap 的区别？</strong></p>
<p>ConcurrentHashMap和HashMap的实现方式不一样，虽然都是使用桶数组实现的，但是还是有区别，ConcurrentHashMap对桶数组进行了分段，而HashMap并没有。</p>
<p>ConcurrentHashMap在每一个分段上都用锁进行了保护。HashMap没有锁机制。所以，前者线程安全的，后者不是线程安全的。</p>
<p>PS：以上区别基于jdk1.8以前的版本。</p>
<h5 id="4-5-List和Set区别"><a href="#4-5-List和Set区别" class="headerlink" title="4.5 List和Set区别"></a>4.5 List和Set区别</h5><p>List,Set都是继承自Collection接口。都是用来存储一组相同类型的元素的。</p>
<p>List特点：元素有放入顺序，元素可重复 。</p>
<p>有顺序，即先放入的元素排在前面。</p>
<p>Set特点：元素无放入顺序，元素不可重复。</p>
<p>无顺序，即先放入的元素不一定排在前面。 不可重复，即相同元素在set中只会保留一份。所以，有些场景下，set可以用来去重。 不过需要注意的是，set在元素插入时是要有一定的方法来判断元素是否重复的。这个方法很重要，决定了set中可以保存哪些元素。</p>
<h5 id="4-6-Set如何保证不重复的元素"><a href="#4-6-Set如何保证不重复的元素" class="headerlink" title="4.6 Set如何保证不重复的元素"></a>4.6 Set如何保证不重复的元素</h5><p>在Java的Set体系中，根据实现方式不同主要分为两大类。HashSet和TreeSet。</p>
<p>1、TreeSet 是二差树实现的,Treeset中的数据是自动排好序的，不允许放入null值 2、HashSet 是哈希表实现的,HashSet中的数据是无序的，可以放入null，但只能放入一个null，两者中的值都不能重复，就如数据库中唯一约束</p>
<p>在HashSet中，基本的操作都是有HashMap底层实现的，因为HashSet底层是用HashMap存储数据的。当向HashSet中添加元素的时候，首先计算元素的hashcode值，然后通过扰动计算和按位与的方式计算出这个元素的存储位置，如果这个位置位空，就将元素添加进去；如果不为空，则用equals方法比较元素是否相等，相等就不添加，否则找一个空位添加。</p>
<p>TreeSet的底层是TreeMap的keySet()，而TreeMap是基于红黑树实现的，红黑树是一种平衡二叉查找树，它能保证任何一个节点的左右子树的高度差不会超过较矮的那棵的一倍。</p>
<p>TreeMap是按key排序的，元素在插入TreeSet时compareTo()方法要被调用，所以TreeSet中的元素要实现Comparable接口。TreeSet作为一种Set，它不允许出现重复元素。TreeSet是用compareTo()来判断重复元素的。</p>
<h5 id="4-7-Java-8中stream相关方法"><a href="#4-7-Java-8中stream相关方法" class="headerlink" title="4.7 Java 8中stream相关方法"></a>4.7 Java 8中stream相关方法</h5><p>在Java中，集合和数组是我们经常会用到的数据结构，需要经常对他们做增、删、改、查、聚合、统计、过滤等操作。相比之下，关系型数据库中也同样有这些操作，但是在Java 8之前，集合和数组的处理并不是很便捷。</p>
<p>不过，这一问题在Java 8中得到了改善，Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。本文就来介绍下如何使用Stream。特别说明一下，关于Stream的性能及原理不是本文的重点，如果大家感兴趣后面会出文章单独介绍。</p>
<p><strong>1）Stream介绍</strong></p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流，流在管道中传输，并且可以在管道的节点上进行处理，比如筛选，排序，聚合等。</p>
<p>Stream有以下特性及优点：</p>
<ul>
<li>无存储。Stream不是一种数据结构，它只是某种数据源的一个视图，数据源可以是一个数组，Java容器或I/O channel等。</li>
<li>为函数式编程而生。对Stream的任何修改都不会修改背后的数据源，比如对Stream执行过滤操作并不会删除被过滤的元素，而是会产生一个不包含被过滤元素的新Stream。</li>
<li>惰式执行。Stream上的操作并不会立即执行，只有等到用户真正需要结果的时候才会执行。</li>
<li>可消费性。Stream只能被“消费”一次，一旦遍历过就会失效，就像容器的迭代器那样，想要再次遍历必须重新生成。</li>
</ul>
<p>我们举一个例子，来看一下到底Stream可以做什么事情：</p>
<p>上面的例子中，获取一些带颜色塑料球作为数据源，首先过滤掉红色的、把它们融化成随机的三角形。再过滤器并删除小的三角形。最后计算出剩余图形的周长。</p>
<p>如上图，对于流的处理，主要有三种关键性操作：分别是流的创建、中间操作（intermediate operation）以及最终操作(terminal operation)。</p>
<p><strong>2）Stream的创建</strong></p>
<p>在Java 8中，可以有多种方法来创建流。</p>
<p><strong>（1）、通过已有的集合来创建流</strong></p>
<p>在Java 8中，除了增加了很多Stream相关的类以外，还对集合类自身做了增强，在其中增加了stream方法，可以将一个集合类转换成流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">Stream&lt;String&gt; stream = strings.stream();</span><br></pre></td></tr></table></figure>
<p>以上，通过一个已有的List创建一个流。除此以外，还有一个parallelStream方法，可以为集合创建一个并行流。</p>
<p>这种通过集合创建出一个Stream的方式也是比较常用的一种方式。</p>
<p><strong>（2）、通过Stream创建流</strong></p>
<p>可以使用Stream类提供的方法，直接返回一个由指定元素组成的流。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br></pre></td></tr></table></figure>
<p>如以上代码，直接通过of方法，创建并返回一个Stream。</p>
<p><strong>2）Stream中间操作</strong></p>
<p>Stream有很多中间操作，多个中间操作可以连接起来形成一个流水线，每一个中间操作就像流水线上的一个工人，每人工人都可以对流进行加工，加工后得到的结果还是一个流。</p>
<p><a href="https://camo.githubusercontent.com/245638178114b71fe0054245f8449c97752ff907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343037353231392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/245638178114b71fe0054245f8449c97752ff907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343037353231392e6a7067" alt="img"></a>￼</p>
<p>以下是常用的中间操作列表:</p>
<p><a href="https://camo.githubusercontent.com/1872cc3bf10ab486bc728651f402137af6768bf3/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343535363438342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1872cc3bf10ab486bc728651f402137af6768bf3/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343535363438342e6a7067" alt="img"></a>￼</p>
<p><strong>filter</strong></p>
<p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤掉空字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">""</span>, <span class="string">"HollisChuang"</span>, <span class="string">"H"</span>, <span class="string">"hollis"</span>);</span><br><span class="line">strings.stream().filter(string -&gt; !string.isEmpty()).forEach(System.out::println);</span><br><span class="line"><span class="comment">//Hollis, , HollisChuang, H, hollis</span></span><br></pre></td></tr></table></figure>
<p><strong>map</strong></p>
<p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().map( i -&gt; i*i).forEach(System.out::println);</span><br><span class="line"><span class="comment">//9,4,4,9,49,9,25</span></span><br></pre></td></tr></table></figure>
<p><strong>limit/skip</strong></p>
<p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素。以下代码片段使用 limit 方法保理4个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().limit(<span class="number">4</span>).forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,2,3</span></span><br></pre></td></tr></table></figure>
<p><strong>sorted</strong></p>
<p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法进行排序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().sorted().forEach(System.out::println);</span><br><span class="line"><span class="comment">//2,2,3,3,3,5,7</span></span><br></pre></td></tr></table></figure>
<p><strong>distinct</strong></p>
<p>distinct主要用来去重，以下代码片段使用 distinct 对元素进行去重：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">numbers.stream().distinct().forEach(System.out::println);</span><br><span class="line"><span class="comment">//3,2,7,5</span></span><br></pre></td></tr></table></figure>
<p>接下来我们通过一个例子和一张图，来演示下，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会发生什么。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">Stream s = strings.stream().filter(string -&gt; string.length()&lt;= <span class="number">6</span>).map(String::length).sorted().limit(<span class="number">3</span>)</span><br><span class="line">            .distinct();</span><br></pre></td></tr></table></figure>
<p>过程及每一步得到的结果如下图：</p>
<p><a href="https://camo.githubusercontent.com/12a4a188624b105b44c05f82810020b6f81ea907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234323032353530362e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/12a4a188624b105b44c05f82810020b6f81ea907/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234323032353530362e6a7067" alt="img"></a>￼</p>
<p><strong>3）Stream最终操作</strong></p>
<p>Stream的中间操作得到的结果还是一个Stream，那么如何把一个Stream转换成我们需要的类型呢？比如计算出流中元素的个数、将流装换成集合等。这就需要最终操作（terminal operation）</p>
<p>最终操作会消耗流，产生一个最终结果。也就是说，在最终操作之后，不能再次使用流，也不能在使用任何中间操作，否则将抛出异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalStateException: stream has already been operated upon or closed</span><br></pre></td></tr></table></figure>
<p>俗话说，“你永远不会两次踏入同一条河”也正是这个意思。</p>
<p>常用的最终操作如下图：</p>
<p><a href="https://camo.githubusercontent.com/59b30017b1c1cb6e224f2d4fb03d6c5bcac4a31f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343630363835312e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/59b30017b1c1cb6e224f2d4fb03d6c5bcac4a31f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313139343630363835312e6a7067" alt="img"></a>￼</p>
<p><strong>forEach</strong></p>
<p>Stream 提供了方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<p><strong>count</strong></p>
<p>count用来统计流中的元素个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>,<span class="string">"Hollis666"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">System.out.println(strings.stream().count());</span><br><span class="line"><span class="comment">//7</span></span><br></pre></td></tr></table></figure>
<p><strong>collect</strong></p>
<p>collect就是一个归约操作，可以接受各种做法作为参数，将流中的元素累积成一个汇总结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">"Hollis"</span>, <span class="string">"HollisChuang"</span>, <span class="string">"hollis"</span>,<span class="string">"Hollis666"</span>, <span class="string">"Hello"</span>, <span class="string">"HelloWorld"</span>, <span class="string">"Hollis"</span>);</span><br><span class="line">strings  = strings.stream().filter(string -&gt; string.startsWith(<span class="string">"Hollis"</span>)).collect(Collectors.toList());</span><br><span class="line">System.out.println(strings);</span><br><span class="line"><span class="comment">//Hollis, HollisChuang, Hollis666, Hollis</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们还是使用一张图，来演示下，前文的例子中，当一个Stream先后通过filter、map、sort、limit以及distinct处理后会，在分别使用不同的最终操作可以得到怎样的结果：</p>
<p>下图，展示了文中介绍的所有操作的位置、输入、输出以及使用一个案例展示了其结果。 <a href="https://camo.githubusercontent.com/aff46cf678b76c862a8583d594844742597cde65/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234353436333732302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/aff46cf678b76c862a8583d594844742597cde65/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353532313234353436333732302e6a7067" alt="img"></a>￼</p>
<p><strong>总结</strong></p>
<p>本文介绍了Java 8中的Stream 的用途，优点等。还接受了Stream的几种用法，分别是Stream创建、中间操作和最终操作。</p>
<p>Stream的创建有两种方式，分别是通过集合类的stream方法、通过Stream的of方法。</p>
<p>Stream的中间操作可以用来处理Stream，中间操作的输入和输出都是Stream，中间操作可以是过滤、转换、排序等。</p>
<p>Stream的最终操作可以将Stream转成其他形式，如计算出流中元素的个数、将流装换成集合、以及元素的遍历等。</p>
<p><strong>4.8 apache集合处理工具类的使用</strong></p>
<p>平常我们在日常的开发中会一些通用的功能封装成一些工具类，以便之后复用。但是有些常用功能，业界已经存在，我们无需造轮子，只需直接使用或借用它们的 Api ，构建我们的自己项目中工具类。这篇首先介绍平常用到的 Apache 工具全家桶。</p>
<ul>
<li>commons-lang3</li>
<li>commons-io</li>
<li>commons-collections</li>
</ul>
<p><strong>commons-lang3</strong></p>
<blockquote>
<p><strong>The standard Java libraries fail to provide enough methods for manipulation of its core classes. Apache Commons Lang provides these extra methods.</strong></p>
</blockquote>
<p>正如 Apache 官方介绍，这个包主要扩展 java.lang 下核心类的方法，提供工具类方便我们平常 java.lang 下面的类，如 String , Date。以下介绍其常用的方法。</p>
<p><strong>StringUtils</strong></p>
<p>字符串相关操作，扩展 String 相关方法，可以使我们方便处理字符串，满足我们的日常使用。</p>
<p>StringUtils.isBlank || StringUtils.isEmpty 判断字符串是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两者都可以用于判断字符串是为空 isBlank 主要用于判断空白字符串 空字符("") 以及Null 而 isEmpty 主要用于判断空字符("")以及Null</span></span><br><span class="line">StringUtils.isBlank(<span class="string">" "</span>)       = <span class="keyword">true</span> </span><br><span class="line">StringUtils.isEmpty(<span class="string">" "</span>)       = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.countMatches 用于计数匹配上字符的数量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.countMatches(<span class="string">"abba"</span>, <span class="string">"a"</span>)   = <span class="number">2</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p>StringUtils.defaultIfEmpty 用于当字符串为空时，设置默认字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.defaultIfEmpty(&quot;&quot;, &quot;NULL&quot;)    = &quot;NULL&quot;</span><br></pre></td></tr></table></figure>
<p>StringUtils.equalsIgnoreCase  StringUtils.equals 用于判断字符串是否相等，前者忽略大小写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringUtils.equals(<span class="string">"abc"</span>, <span class="string">"abc"</span>) = <span class="keyword">true</span></span><br><span class="line">StringUtils.equalsIgnoreCase(<span class="string">"abc"</span>, <span class="string">"ABC"</span>) = <span class="keyword">true</span></span><br><span class="line"><span class="comment">// 推荐使用该方法比较字符串，如果使用 a.equals(b),必须确保 a!=null</span></span><br><span class="line">StringUtils.equals(<span class="keyword">null</span>, <span class="string">"abc"</span>)  = <span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.join 字符串连接函数，可以将字符串数组或集合，按照指定字符连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 碰到这种需要固定分隔符拼接的情况，可以使用该函数，以免我们写一大串函数循环拼接</span></span><br><span class="line">StringUtils.join([<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>], <span class="string">';'</span>)  = <span class="string">"a;b;c"</span></span><br></pre></td></tr></table></figure>
<p>StringUtils.split 说完拼接，必定会有按照固定分隔符拆分的情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// split 分隔后会忽略为空的字符 如果不能忽略的话 使用 splitPreserveAllTokens</span></span><br><span class="line">StringUtils.split(<span class="string">"ab::ef"</span>, <span class="string">":"</span>) = [<span class="string">"ab"</span>, <span class="string">"ef"</span>]</span><br><span class="line">StringUtils.splitPreserveAllTokens(<span class="string">"ab::ef"</span>,<span class="string">":"</span>)=[<span class="string">"ab"</span>, <span class="string">""</span>, <span class="string">"ef"</span>]</span><br></pre></td></tr></table></figure>
<p><strong>ArrayUtils</strong></p>
<p>由于平常工作中习惯用集合代替数组对象，所以没有经常使用该类。</p>
<p>ArrayUtils.isEmpty 判断数组是否为空</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line">ArrayUtils.isEmpty(a)=<span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p><strong>DateFormatUtils</strong></p>
<p>将时间按照指定格式输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DateFormatUtils.format(<span class="keyword">new</span> Date(), <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line"><span class="comment">//2018-05-27 16:32:51</span></span><br></pre></td></tr></table></figure>
<p><strong>DateUtils</strong></p>
<p>该类可以将时间按照格式解析成 Date 类型，还可以用于时间计算</p>
<p>DateUtils.parseDate 按照格式转化成 Date 类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>) <span class="comment">// 将字符串转化成 Date 对象</span></span><br></pre></td></tr></table></figure>
<p>DateUtils.addDays addHours addMinutes 用于在指定 Date 加上相应时间，如想获取当前时间20天后的日期，就就可以使用 DateUtils.addDays。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">DateUtils.addDays(date,<span class="number">1</span>);<span class="comment">// date 为：2018-05-28 16:32:51</span></span><br><span class="line">DateUtils.addHours(date,<span class="number">1</span>)<span class="comment">// date 为：2018-05-28 17:32:51</span></span><br></pre></td></tr></table></figure>
<p>DateUtils.truncate 按照指定时间类型截断时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Date date=DateUtils.parseDate(<span class="string">"2018-05-27 16:32:51"</span>,<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">DateUtils.truncate(date, Calendar.DATE);<span class="comment">// 2018-05-27 00:00:00</span></span><br><span class="line">DateUtils.truncate(date, Calendar.HOUR);<span class="comment">// 2018-05-27 16:00:00</span></span><br><span class="line"><span class="comment">// 如果按照 Date 截断时间，那么 Date 后面小时，分钟等全部置为0，相当于舍弃了 Date 之后的时间。</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>
<p><strong>commons-io</strong></p>
<blockquote>
<p><strong>Commons IO is a library of utilities to assist with developing IO functionality.</strong></p>
</blockquote>
<p>主要包含一些 IO 相关的工具类,可以简化处理文件相关操作</p>
<p><strong>FileUtils</strong></p>
<p>文件操作相关工具类</p>
<p>FileUtils.copyDirectory || FileUtils.copyFile 拷贝文件夹或文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝文件</span></span><br><span class="line">File fileA = <span class="keyword">new</span> File(<span class="string">"E:\\test\\test.txt"</span>);</span><br><span class="line">File fileB = <span class="keyword">new</span> File(<span class="string">"E:\\test1\\test.txt"</span>);</span><br><span class="line">FileUtils.copyFile(fileA,fileB);</span><br></pre></td></tr></table></figure>
<p>FileUtils.listFiles 获取指定文件夹上所有文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按照指定文件后缀如java,txt等去查找指定文件夹的文件</span></span><br><span class="line">File directory = <span class="keyword">new</span> File(<span class="string">"E:\\test"</span>);</span><br><span class="line">FileUtils.listFiles(directory, <span class="keyword">new</span> String[]&#123;<span class="string">"txt"</span>&#125;, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>FileUtils.readLines 读取文件所有行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取指定文件所有行 不需要使用 while 循环读取流了</span></span><br><span class="line">List&lt;String&gt; lines = FileUtils.readLines(fileA)</span><br></pre></td></tr></table></figure>
<p>FileUtils.writeLines 有读就存在写，该方法可以一行行写入文本</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以一行行写入文本</span></span><br><span class="line">List&lt;String&gt; lines = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">.....</span><br><span class="line">FileUtils.writeLines(lines)</span><br></pre></td></tr></table></figure>
<p><strong>IOUtils</strong></p>
<p>Io 操作相关，FileUtils 很多方法底层调用的是该类的方法</p>
<p>IOUtils.toString 将输入流转化为指定编码格式的字符串，该方法非常使用与 http 异步回调的场景</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 http 异步回调的报文</span></span><br><span class="line">String resMsg = IOUtils.toString(request.getInputStream());</span><br></pre></td></tr></table></figure>
<p>IOUtils.toByteArray 将输入流转化为 byte 数组</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 http 异步回调的报文</span></span><br><span class="line"><span class="keyword">byte</span>[] b = IOUtils.toByteArray(request.getInputStream());</span><br></pre></td></tr></table></figure>
<p>IOUtils.closeQuietly 关闭流，不需要在关闭前写判断和try-catch语句，commons-io 2.6 该方法已被 <strong>Deprecated</strong> ， 官方推荐使用 JDK7 try-with-resources 关闭。<strong>注：</strong> <em>该方法如果在输入流等 close 时，若产生 Exception ，异常将会被该方法吞掉。</em></p>
<p><strong>FilenameUtils</strong></p>
<p>在处理一些文件路径问题时，如果我们代码开发在 Windows 平台，部署却是在 Linux 平台，这个时候我们必须考虑平台分隔符问题。FilenameUtils 解决了平台问题，不用担心平台系统问题，导致的bug。</p>
<p>FilenameUtils.getBaseName 获取文件名字，去除前缀加扩展名 FilenameUtils.getExtension 获取文件扩展名，去除路径以及文件名 FilenameUtils.getName 获取文件全名，去除路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FilenameUtils.getBaseName(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">//test</span></span><br><span class="line">FilenameUtils.getExtension(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">//txt</span></span><br><span class="line">FilenameUtils.getName(<span class="string">"E:\\test\\test.txt"</span>)<span class="comment">// test.txt</span></span><br></pre></td></tr></table></figure>
<p>FilenameUtils.concat 文件路径拼接，不用担心文件的分隔符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FilenameUtils.concat(<span class="string">"E:\\test"</span>, <span class="string">"test.txt"</span>);<span class="comment">//E:\test\test.txt</span></span><br></pre></td></tr></table></figure>
<p><strong>commons-collections</strong></p>
<blockquote>
<p><strong>The Java Collections Framework was a major addition in JDK 1.2. It added many powerful data structures that accelerate development of most significant Java applications. Since that time it has become the recognised standard for collection handling in Java</strong></p>
</blockquote>
<p>commons-collections 主要增强 java Collections 功能</p>
<p><strong>CollectionUtils</strong></p>
<p>为 Collection 实例提供工具方法</p>
<p>CollectionUtils.addAll 可以将数组，集合加入到指定集合，解决需要将数组加入到集合中情况</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; listA = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">listA.add(<span class="string">"1"</span>);</span><br><span class="line">listA.add(<span class="string">"2"</span>);</span><br><span class="line">listA.add(<span class="string">"3"</span>);</span><br><span class="line">String[] arrays = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line">CollectionUtils.addAll(listA, arrays);</span><br></pre></td></tr></table></figure>
<p>CollectionUtils.isEmpty CollectionUtils.isNotEmpty 快捷判断集合是否为空</p>
<h5 id="4-9-Collection和Collections区别"><a href="#4-9-Collection和Collections区别" class="headerlink" title="4.9 Collection和Collections区别"></a>4.9 Collection和Collections区别</h5><p>Collection 是一个集合接口。 它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。是list，set等的父接口。</p>
<p>Collections 是一个包装类。 它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。</p>
<p>日常开发中，不仅要了解Java中的Collection及其子类的用法，还要了解Collections用法。可以提升很多处理集合类的效率。</p>
<h5 id="4-10-Arrays-asList获得的List使用时需要注意什么"><a href="#4-10-Arrays-asList获得的List使用时需要注意什么" class="headerlink" title="4.10 Arrays.asList获得的List使用时需要注意什么"></a>4.10 Arrays.asList获得的List使用时需要注意什么</h5><ol>
<li>asList 得到的只是一个 Arrays 的内部类，一个原来数组的视图 List，因此如果对它进行增删操作会报错</li>
<li>用 ArrayList 的构造器可以将其转变成真正的 ArrayList</li>
</ol>
<h5 id="4-11-Enumeration和Iterator区别"><a href="#4-11-Enumeration和Iterator区别" class="headerlink" title="4.11 Enumeration和Iterator区别"></a>4.11 Enumeration和Iterator区别</h5><p>函数接口不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enumeration只有<span class="number">2</span>个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。</span><br><span class="line">Iterator只有<span class="number">3</span>个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</span><br></pre></td></tr></table></figure>
<p>Iterator支持fail-fast机制，而Enumeration不支持。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enumeration 是JDK <span class="number">1.0</span>添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK <span class="number">1.0</span>中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。</span><br><span class="line">而Iterator 是JDK <span class="number">1.2</span>才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</span><br></pre></td></tr></table></figure>
<p>注意：Enumeration迭代器只能遍历Vector、Hashtable这种古老的集合，因此通常不要使用它，除非在某些极端情况下，不得不使用Enumeration，否则都应该选择Iterator迭代器。</p>
<h5 id="4-12-CopyOnWriteArrayList"><a href="#4-12-CopyOnWriteArrayList" class="headerlink" title="4.12 CopyOnWriteArrayList"></a>4.12 CopyOnWriteArrayList</h5><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。</p>
<p>CopyOnWriteArrayList相当于线程安全的ArrayList，CopyOnWriteArrayList使用了一种叫写时复制的方法，当有新元素add到CopyOnWriteArrayList时，先从原有的数组中拷贝一份出来，然后在新的数组做写操作，写完之后，再将原来的数组引用指向到新数组。</p>
<p>这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p>
<p>注意：CopyOnWriteArrayList的整个add操作都是在锁的保护下进行的。也就是说add方法是线程安全的。</p>
<p>CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p>
<p>和ArrayList不同的是，它具有以下特性：</p>
<p>支持高效率并发且是线程安全的 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove() 等等）的开销很大 迭代器支持hasNext(), next()等不可变操作，但不支持可变 remove()等操作 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照</p>
<h5 id="4-13-ConcurrentSkipListMap"><a href="#4-13-ConcurrentSkipListMap" class="headerlink" title="4.13 ConcurrentSkipListMap"></a>4.13 ConcurrentSkipListMap</h5><p>ConcurrentSkipListMap是一个内部使用跳表，并且支持排序和并发的一个Map，是线程安全的。一般很少会被用到，也是一个比较偏门的数据结构。</p>
<p>简单介绍下跳表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">跳表是一种允许在一个有顺序的序列中进行快速查询的数据结构。</span><br><span class="line"></span><br><span class="line">在普通的顺序链表中查询一个元素，需要从链表头部开始一个一个节点进行遍历，然后找到节点。如图<span class="number">1</span>。</span><br><span class="line"></span><br><span class="line">跳表可以解决这种查询时间过长，其元素遍历的图示如图<span class="number">2</span>，跳表是一种使用”空间换时间”的概念用来提高查询效率的链表。</span><br></pre></td></tr></table></figure>
<p>ConcurrentSkipListMap 和 ConcurrentHashMap 的主要区别： a.底层实现方式不同。ConcurrentSkipListMap底层基于跳表。ConcurrentHashMap底层基于Hash桶和红黑树。 b.ConcurrentHashMap不支持排序。ConcurrentSkipListMap支持排序。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/16/JAVA基础篇（二）————基础知识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/JAVA基础篇（二）————基础知识/" itemprop="url">JAVA基础篇（二）————基础知识</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-16T16:41:29+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="二、JAVA基础知识"><a href="#二、JAVA基础知识" class="headerlink" title="二、JAVA基础知识"></a>二、JAVA基础知识</h3><h4 id="1、基础数据类型"><a href="#1、基础数据类型" class="headerlink" title="1、基础数据类型"></a>1、基础数据类型</h4><p>Java中有8种基本数据类型 分为三大类。</p>
<p>字符型：char</p>
<p>布尔型：boolean</p>
<p>数值型： 1.整型：byte、short、int、long 2.浮点型：float、double</p>
<p>String不是基本数据类型，是引用类型。</p>
<hr>
<p>Java中的整型主要包含byte、short、int和long这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p>
<p>先来个简答的科普，1字节=8位（bit）。java中的整型属于有符号数。</p>
<p>先来看计算中8bit可以表示的数字： 最小值：10000000 （-128）(-2^7) 最大值：01111111（127）(2^7-1) 具体计算方式参考：Java中，为什么byte类型的取值范围为-128~127? - CSDN博客</p>
<p>整型的这几个类型中，</p>
<p>　　byte：byte用1个字节来存储，范围为-128(-2^7)到127(2^7-1)，在变量初始化的时候，byte类型的默认值为0。</p>
<p>　　short：short用2个字节存储，范围为-32,768 (-2^15)到32,767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。</p>
<p>　　int：int用4个字节存储，范围为-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)，在变量初始化的时候，int类型的默认值为0。</p>
<p>　　long：long用8个字节存储，范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。</p>
<p>上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> j = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br><span class="line">System.out.println(<span class="string">"i ("</span> + i + <span class="string">") + j ("</span> + j + <span class="string">") = k ("</span> + k + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：i (2147483647) + j (2147483647) = k (-2)</p>
<p>这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。所以，在程序中，使用同类型的数据进行运算的时候，一定要注意数据溢出的问题。</p>
<p><strong>浮点型</strong></p>
<p>在计算机科学中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。</p>
<p>计算机使用浮点数运算的主因，在于电脑使用二进位制的运算。例如：4÷2=2，4的二进制表示为100、2的二进制表示为010，在二进制中，相当于退一位数(100 -&gt; 010)。</p>
<p>1的二进制是01，1.0/2=0.5，那么，0.5的二进制表示应该为(0.1)，以此类推，0.25的二进制表示为0.01，所以，并不是说所有的十进制小数都能准确的用二进制表示出来，如0.1，因此只能使用近似值的方式表达。</p>
<p>也就是说，，十进制的小数在计算机中是由一个整数或定点数（即尾数）乘以某个基数（计算机中通常是2）的整数次幂得到的，这种表示方法类似于基数为10的科学计数法。</p>
<p>一个浮点数a由两个数m和e来表示：a = m × be。在任意一个这样的系统中，我们选择一个基数b（记数系统的基）和精度p（即使用多少位来存储）。m（即尾数）是形如±d.ddd…ddd的p位数（每一位是一个介于0到b-1之间的整数，包括0和b-1）。如果m的第一位是非0整数，m称作正规化的。有一些描述使用一个单独的符号位（s 代表+或者-）来表示正负，这样m必须是正的。e是指数。</p>
<p>位（bit）是衡量浮点数所需存储空间的单位，通常为32位或64位，分别被叫作单精度和双精度。</p>
<p><strong>单精度和双精度</strong></p>
<p>单精度浮点数在计算机存储器中占用4个字节（32 bits），利用“浮点”（浮动小数点）的方法，可以表示一个范围很大的数值。</p>
<p>比起单精度浮点数，双精度浮点数(double)使用 64 位（8字节） 来存储一个浮点数。</p>
<p><strong>为什么不能用浮点数表示金额</strong></p>
<p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>
<p>建议使用BigDecimal或者Long（单位为分）来表示金额。</p>
<h4 id="2、自动拆装箱"><a href="#2、自动拆装箱" class="headerlink" title="2、自动拆装箱"></a>2、自动拆装箱</h4><h5 id="2-1-什么是包装类型、什么是基本类型、什么是自动拆装箱"><a href="#2-1-什么是包装类型、什么是基本类型、什么是自动拆装箱" class="headerlink" title="2.1 什么是包装类型、什么是基本类型、什么是自动拆装箱"></a>2.1 什么是包装类型、什么是基本类型、什么是自动拆装箱</h5><p>基本类型，或者叫做内置类型，是Java中不同于类(Class)的特殊类型。它们是我们编程中使用最频繁的类型。</p>
<p>Java是一种强类型语言，第一次申明变量必须说明数据类型，第一次变量赋值称为变量的初始化。</p>
<p>Java基本类型共有八种，基本类型可以分为三类：</p>
<blockquote>
<p><strong>字符类型<code>char</code></strong></p>
<p><strong>布尔类型<code>boolean</code></strong></p>
<p><strong>数值类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>、<code>float</code>、<code>double</code>。</strong></p>
</blockquote>
<p>数值类型又可以分为整数类型<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code>和浮点数类型<code>float</code>、<code>double</code>。</p>
<p>Java中的数值类型不存在无符号的，它们的取值范围是固定的，不会随着机器硬件环境或者操作系统的改变而改变。</p>
<p>实际上，Java中还存在另外一种基本类型<code>void</code>，它也有对应的包装类 <code>java.lang.Void</code>，不过我们无法直接对它们进行操作。</p>
<p><strong>基本数据类型有什么好处</strong></p>
<p>我们都知道在Java语言中，<code>new</code>一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。</p>
<p>对于经常用到的类型，如int等，如果我们每次使用这种变量的时候都需要new一个Java对象的话，就会比较笨重。所以，和C++一样，Java提供了基本数据类型，这种数据的变量不需要使用new创建，他们不会在堆上创建，而是直接在栈内存中存储，因此会更加高效。</p>
<p><strong>整型的取值范围</strong></p>
<p>Java中的整型主要包含<code>byte</code>、<code>short</code>、<code>int</code>和<code>long</code>这四种，表示的数字范围也是从小到大的，之所以表示范围不同主要和他们存储数据时所占的字节数有关。</p>
<p>先来个简答的科普，1字节=8位（bit）。java中的整型属于有符号数。</p>
<p>先来看计算中8bit可以表示的数字：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">最小值：<span class="number">10000000</span> （-<span class="number">128</span>）(-<span class="number">2</span>^<span class="number">7</span>)</span><br><span class="line">最大值：<span class="number">01111111</span>（<span class="number">127</span>）(<span class="number">2</span>^<span class="number">7</span>-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>整型的这几个类型中，</p>
<ul>
<li>byte：byte用1个字节来存储，范围为-128(-2^7)到127(2^7-1)，在变量初始化的时候，byte类型的默认值为0。</li>
<li>short：short用2个字节存储，范围为-32,768 (-2^15)到32,767 (2^15-1)，在变量初始化的时候，short类型的默认值为0，一般情况下，因为Java本身转型的原因，可以直接写为0。</li>
<li>int：int用4个字节存储，范围为-2,147,483,648 (-2^31)到2,147,483,647 (2^31-1)，在变量初始化的时候，int类型的默认值为0。</li>
<li>long：long用8个字节存储，范围为-9,223,372,036,854,775,808 (-2^63)到9,223,372,036, 854,775,807 (2^63-1)，在变量初始化的时候，long类型的默认值为0L或0l，也可直接写为0。</li>
</ul>
<p><strong>超出范围怎么办</strong></p>
<p>上面说过了，整型中，每个类型都有一定的表示范围，但是，在程序中有些计算会导致超出表示范围，即溢出。如以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> j = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> k = i + j;</span><br><span class="line">System.out.println(<span class="string">"i ("</span> + i + <span class="string">") + j ("</span> + j + <span class="string">") = k ("</span> + k + <span class="string">")"</span>);</span><br></pre></td></tr></table></figure>
<p>输出结果：i (2147483647) + j (2147483647) = k (-2)</p>
<p><strong>这就是发生了溢出，溢出的时候并不会抛异常，也没有任何提示。</strong>所以，在程序中，使用同类型的数据进行运算的时候，<strong>一定要注意数据溢出的问题。</strong></p>
<p><strong>包装类型</strong></p>
<p>Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类(Wrapper Class)。</p>
<p>包装类均位于java.lang包，包装类和基本数据类型的对应关系如下表所示</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>Byte</td>
</tr>
<tr>
<td>boolean</td>
<td>Boolean</td>
</tr>
<tr>
<td>short</td>
<td>Short</td>
</tr>
<tr>
<td>char</td>
<td>Character</td>
</tr>
<tr>
<td>int</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>Double</td>
</tr>
</tbody>
</table>
</div>
<p>在这八个类名中，除了Integer和Character类以后，其它六个类的类名和基本数据类型一致，只是类名的第一个字母大写即可。</p>
<p><strong>为什么需要包装类</strong></p>
<p>很多人会有疑问，既然Java中为了提高效率，提供了八种基本数据类型，为什么还要提供包装类呢？</p>
<p>这个问题，其实前面已经有了答案，因为Java是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将int 、double等类型放进去的。因为集合的容器要求元素是Object类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型，它相当于将基本类型“包装起来”，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<p><strong>拆箱与装箱</strong></p>
<p>那么，有了基本数据类型和包装类，肯定有些时候要在他们之间进行转换。比如把一个基本数据类型的int转换成一个包装类型的Integer对象。</p>
<p>我们认为包装类是对基本类型的包装，所以，把基本数据类型转换成包装类的过程就是打包装，英文对应于boxing，中文翻译为装箱。</p>
<p>反之，把包装类转换成基本数据类型的过程就是拆包装，英文对应于unboxing，中文翻译为拆箱。</p>
<p>在Java SE5之前，要进行装箱，可以通过以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p><strong>自动拆箱与自动装箱</strong></p>
<p>在Java SE5中，为了减少开发人员的工作，Java提供了自动拆箱与自动装箱功能。</p>
<p>自动装箱: 就是将基本数据类型自动转换成对应的包装类。</p>
<p>自动拆箱：就是将包装类自动转换成对应的基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i =<span class="number">10</span>;  <span class="comment">//自动装箱</span></span><br><span class="line"><span class="keyword">int</span> b= i;     <span class="comment">//自动拆箱</span></span><br></pre></td></tr></table></figure>
<p><code>Integer i=10</code> 可以替代 <code>Integer i = new Integer(10);</code>，这就是因为Java帮我们提供了自动装箱的功能，不需要开发者手动去new一个Integer对象。</p>
<p><strong>自动装箱与自动拆箱的实现原理</strong></p>
<p>既然Java提供了自动拆装箱的能力，那么，我们就来看一下，到底是什么原理，Java是如何实现的自动拆装箱功能。</p>
<p>我们有以下自动拆装箱的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    Integer integer=<span class="number">1</span>; <span class="comment">//装箱</span></span><br><span class="line">    <span class="keyword">int</span> i=integer; <span class="comment">//拆箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对以上代码进行反编译后可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">    Integer integer=Integer.valueOf(<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">int</span> i=integer.intValue(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面反编译后的代码可以看出，int的自动装箱都是通过<code>Integer.valueOf()</code>方法来实现的，Integer的自动拆箱都是通过<code>integer.intValue</code>来实现的。如果读者感兴趣，可以试着将八种类型都反编译一遍 ，你会发现以下规律：</p>
<blockquote>
<p><strong>自动装箱都是通过包装类的<code>valueOf()</code>方法来实现的.自动拆箱都是通过包装类对象的<code>xxxValue()</code>来实现的。</strong></p>
</blockquote>
<p><strong>哪些地方会自动拆装箱</strong></p>
<p>我们了解过原理之后，在来看一下，什么情况下，Java会帮我们进行自动拆装箱。前面提到的变量的初始化和赋值的场景就不介绍了，那是最简单的也最容易理解的。</p>
<p>我们主要来看一下，那些可能被忽略的场景。</p>
<p><strong>场景一、将基本数据类型放入集合类</strong></p>
<p>我们知道，Java中的集合类只能接收对象类型，那么以下代码为什么会不报错呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i ++)&#123;</span><br><span class="line">    li.add(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上面代码进行反编译，可以得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">50</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">    li.add(Integer.valueOf(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上，我们可以得出结论，当我们把基本数据类型放入集合类中的时候，会进行自动装箱。</p>
<p><strong>场景二、包装类型和基本类型的大小比较</strong></p>
<p>有没有人想过，当我们对Integer对象与基本类型进行大小比较的时候，实际上比较的是什么内容呢？看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a==<span class="number">1</span>?<span class="string">"等于"</span>:<span class="string">"不等于"</span>);</span><br><span class="line">Boolean bool=<span class="keyword">false</span>;</span><br><span class="line">System.out.println(bool?<span class="string">"真"</span>:<span class="string">"假"</span>);</span><br></pre></td></tr></table></figure>
<p>对以上代码进行反编译，得到以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer a=<span class="number">1</span>;</span><br><span class="line">System.out.println(a.intValue()==<span class="number">1</span>?<span class="string">"等于"</span>:<span class="string">"不等于"</span>);</span><br><span class="line">Boolean bool=<span class="keyword">false</span>;</span><br><span class="line">System.out.println(bool.booleanValue?<span class="string">"真"</span>:<span class="string">"假"</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到，包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。</p>
<p><strong>场景三、包装类型的运算</strong></p>
<p>有没有人想过，当我们对Integer对象进行四则运算的时候，是如何进行的呢？看以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">10</span>;</span><br><span class="line">Integer j = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">System.out.println(i+j);</span><br></pre></td></tr></table></figure>
<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = Integer.valueOf(<span class="number">10</span>);</span><br><span class="line">Integer j = Integer.valueOf(<span class="number">20</span>);</span><br><span class="line">System.out.println(i.intValue() + j.intValue());</span><br></pre></td></tr></table></figure>
<p>我们发现，两个包装类型之间的运算，会被自动拆箱成基本类型进行。</p>
<p><strong>场景四、三目运算符的使用</strong></p>
<p>这是很多人不知道的一个场景，作者也是一次线上的血淋淋的Bug发生后才了解到的一种案例。看一个简单的三目运算符的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Integer i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = flag ? i : j;</span><br></pre></td></tr></table></figure>
<p>很多人不知道，其实在<code>int k = flag ? i : j;</code>这一行，会发生自动拆箱。反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">Integer i = Integer.valueOf(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k = flag ? i.intValue() : j;</span><br><span class="line">System.out.println(k);</span><br></pre></td></tr></table></figure>
<p>这其实是三目运算符的语法规范。当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。</p>
<p>因为例子中，<code>flag ? i : j;</code>片段中，第二段的i是一个包装类型的对象，而第三段的j是一个基本类型，所以会对包装类进行自动拆箱。如果这个时候i的值为<code>null</code>，那么就会发生NPE。（<a href="http://www.hollischuang.com/archives/435" target="_blank" rel="noopener">自动拆箱导致空指针异常</a>）</p>
<p><strong>场景五、函数参数与返回值</strong></p>
<p>这个比较容易理解，直接上代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自动拆箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum1</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自动装箱</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getNum2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自动拆装箱与缓存</strong></p>
<p>Java SE的自动拆装箱还提供了一个和缓存有关的功能，我们先来看以下代码，猜测一下输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... strings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Integer integer1 = <span class="number">3</span>;</span><br><span class="line">    Integer integer2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">        System.out.println(<span class="string">"integer1 == integer2"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer1 != integer2"</span>);</span><br><span class="line"></span><br><span class="line">    Integer integer3 = <span class="number">300</span>;</span><br><span class="line">    Integer integer4 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">        System.out.println(<span class="string">"integer3 == integer4"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">"integer3 != integer4"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们普遍认为上面的两个判断的结果都是false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个if判断都是false的。在Java中，==比较的是对象应用，而equals比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>上面这段代码真正的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer1 == integer2</span><br><span class="line">integer3 != integer4</span><br></pre></td></tr></table></figure>
<p>原因就和Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p><strong>适用于整数值区间-128 至 +127。</strong></p>
<p><strong>只适用于自动装箱。使用构造函数创建对象不适用。</strong></p>
</blockquote>
<p>具体的代码实现可以阅读<a href="http://www.hollischuang.com/archives/1174" target="_blank" rel="noopener">Java中整型的缓存机制</a>一文，这里不再阐述。</p>
<p>我们只需要知道，当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。</p>
<p>其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过<code>-XX:AutoBoxCacheMax=size</code>修改。</p>
<p>实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过<code>java.lang.Integer.IntegerCache.high</code>设置最大值。</p>
<p>这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？因为这个范围的数字是最被广泛使用的。 在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p>
<p>在Boxing Conversion部分的Java语言规范(JLS)规定如下：</p>
<p>如果一个变量p的值是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="number">128</span>至<span class="number">127</span>之间的整数(§<span class="number">3.10</span>.1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">true</span> 和 <span class="keyword">false</span>的布尔值 (§<span class="number">3.10</span>.3)</span><br><span class="line"></span><br><span class="line">‘\u0000’至 ‘\u007f’之间的字符(§<span class="number">3.10</span>.4)</span><br></pre></td></tr></table></figure>
<p>范围内的时，将p包装成a和b两个对象时，可以直接使用a==b判断a和b的值是否相等。</p>
<p><strong>自动拆装箱带来的问题</strong></p>
<p>当然，自动拆装箱是一个很好的功能，大大节省了开发人员的精力，不再需要关心到底什么时候需要拆装箱。但是，他也会引入一些问题。</p>
<blockquote>
<p><strong>包装对象的数值比较，不能简单的使用<code>==</code>，虽然-128到127之间的数字可以，但是这个范围之外还是需要使用<code>equals</code>比较。</strong></p>
<p><strong>前面提到，有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为null，那么自动拆箱时就有可能抛出NPE。</strong></p>
<p><strong>如果一个for循环中有大量拆装箱操作，会浪费很多资源。</strong></p>
</blockquote>
<h5 id="2-2-Integer的缓存机制"><a href="#2-2-Integer的缓存机制" class="headerlink" title="2.2 Integer的缓存机制"></a>2.2 Integer的缓存机制</h5><p>本文将介绍Java中Integer的缓存相关知识。这是在Java 5中引入的一个有助于节省内存、提高性能的功能。首先看一个使用Integer的示例代码，从中学习其缓存行为。接着我们将为什么这么实现以及他到底是如何实现的。你能猜出下面的Java程序的输出结果吗。如果你的结果和真正结果不一样，那么你就要好好看看本文了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javapapers.java;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... strings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Integer integer1 = <span class="number">3</span>;</span><br><span class="line">        Integer integer2 = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">            System.out.println(<span class="string">"integer1 == integer2"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"integer1 != integer2"</span>);</span><br><span class="line"></span><br><span class="line">        Integer integer3 = <span class="number">300</span>;</span><br><span class="line">        Integer integer4 = <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">            System.out.println(<span class="string">"integer3 == integer4"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"integer3 != integer4"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们普遍认为上面的两个判断的结果都是false。虽然比较的值是相等的，但是由于比较的是对象，而对象的引用不一样，所以会认为两个if判断都是false的。在Java中，<code>==</code>比较的是对象应用，而<code>equals</code>比较的是值。所以，在这个例子中，不同的对象有不同的引用，所以在进行比较的时候都将返回false。奇怪的是，这里两个类似的if条件判断返回不同的布尔值。</p>
<p>上面这段代码真正的输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">integer1 == integer2</span><br><span class="line">integer3 != integer4</span><br></pre></td></tr></table></figure>
<p><strong>Java中Integer的缓存实现</strong></p>
<p>在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。</p>
<blockquote>
<p>适用于整数值区间-128 至 +127。</p>
<p>只适用于自动装箱。使用构造函数创建对象不适用。</p>
</blockquote>
<p>Java的编译器把基本数据类型自动转换成封装类对象的过程叫做<code>自动装箱</code>，相当于使用<code>valueOf</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">10</span>; <span class="comment">//this is autoboxing</span></span><br><span class="line">Integer b = Integer.valueOf(<span class="number">10</span>); <span class="comment">//under the hood</span></span><br></pre></td></tr></table></figure>
<p>现在我们知道了这种机制在源码中哪里使用了，那么接下来我们就看看JDK中的<code>valueOf</code>方法。下面是<code>JDK 1.8.0 build 25</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an &#123;<span class="doctag">@code</span> Integer&#125; instance representing the specified</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> int&#125; value.  If a new &#123;<span class="doctag">@code</span> Integer&#125; instance is not</span></span><br><span class="line"><span class="comment">     * required, this method should generally be used in preference to</span></span><br><span class="line"><span class="comment">     * the constructor &#123;<span class="doctag">@link</span> #Integer(int)&#125;, as this method is likely</span></span><br><span class="line"><span class="comment">     * to yield significantly better space and time performance by</span></span><br><span class="line"><span class="comment">     * caching frequently requested values.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * This method will always cache values in the range -128 to 127,</span></span><br><span class="line"><span class="comment">     * inclusive, and may cache other values outside of this range.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  i an &#123;<span class="doctag">@code</span> int&#125; value.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an &#123;<span class="doctag">@code</span> Integer&#125; instance representing &#123;<span class="doctag">@code</span> i&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span>  1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在创建对象之前先从IntegerCache.cache中寻找。如果没找到才使用new新建对象。</p>
<p><strong>IntegerCache Class</strong></p>
<p>IntegerCache是Integer类中定义的一个<code>private static</code>的内部类。接下来看看他的定义。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment">   * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment">   * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&#125; option.</span></span><br><span class="line"><span class="comment">   * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment">   * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment">   * sun.misc.VM class.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">          <span class="comment">// high value may be configured by property</span></span><br><span class="line">          <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">          String integerCacheHighPropValue =</span><br><span class="line">              sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">          <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                  i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                  <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                  h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                  <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          high = h;</span><br><span class="line"></span><br><span class="line">          cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">          <span class="keyword">int</span> j = low;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">              cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">          <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>其中的javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过<code>-XX:AutoBoxCacheMax=size</code>修改。 缓存通过一个for循环实现。从低到高并创建尽可能多的整数并存储在一个整数数组中。这个缓存会在Integer类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p>
<p>实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过<code>java.lang.Integer.IntegerCache.high</code>设置最大值。这使我们可以根据应用程序的实际情况灵活地调整来提高性能。到底是什么原因选择这个-128到127范围呢？因为这个范围的数字是最被广泛使用的。 在程序中，第一次使用Integer的时候也需要一定的额外时间来初始化这个缓存。</p>
<p><strong>Java语言规范中的缓存行为</strong></p>
<p>在<a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.7" target="_blank" rel="noopener">Boxing Conversion</a>部分的Java语言规范(JLS)规定如下：</p>
<blockquote>
<p><strong>如果一个变量p的值是：</strong></p>
<p><strong>-128至127之间的整数(§3.10.1)</strong></p>
<p><strong>true 和 false的布尔值 (§3.10.3)</strong></p>
<p><strong>‘\u0000’至 ‘\u007f’之间的字符(§3.10.4)</strong></p>
<p><strong>中时，将p包装成a和b两个对象时，可以直接使用a==b判断a和b的值是否相等。</strong></p>
</blockquote>
<p><strong>其他缓存的对象</strong></p>
<p>这种缓存行为不仅适用于Integer对象。我们针对所有的整数类型的类都有类似的缓存机制。</p>
<blockquote>
<p><strong>有ByteCache用于缓存Byte对象</strong></p>
<p><strong>有ShortCache用于缓存Short对象</strong></p>
<p><strong>有LongCache用于缓存Long对象</strong></p>
<p><strong>有CharacterCache用于缓存Character对象</strong></p>
</blockquote>
<p><code>Byte</code>, <code>Short</code>, <code>Long</code>有固定范围: -128 到 127。对于<code>Character</code>, 范围是 0 到 127。除了<code>Integer</code>以外，这个范围都不能改变。</p>
<h4 id="3、String"><a href="#3、String" class="headerlink" title="3、String"></a>3、String</h4><p><strong>创建字符串</strong></p>
<p>创建字符串最简单的方式如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String greeting = <span class="string">"菜鸟教程"</span>;</span><br></pre></td></tr></table></figure>
<p>String方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">SN(序号)</th>
<th style="text-align:left">方法描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-charat.html" target="_blank" rel="noopener">char charAt(int index)</a> 返回指定索引处的 char 值。</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(Object o)</a> 把这个字符串和另一个对象比较。</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-compareto.html" target="_blank" rel="noopener">int compareTo(String anotherString)</a> 按字典顺序比较两个字符串。</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-comparetoignorecase.html" target="_blank" rel="noopener">int compareToIgnoreCase(String str)</a> 按字典顺序比较两个字符串，不考虑大小写。</td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-concat.html" target="_blank" rel="noopener">String concat(String str)</a> 将指定字符串连接到此字符串的结尾。</td>
</tr>
<tr>
<td style="text-align:left">6</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-contentequals.html" target="_blank" rel="noopener">boolean contentEquals(StringBuffer sb)</a> 当且仅当字符串与指定的StringBuffer有相同顺序的字符时候返回真。</td>
</tr>
<tr>
<td style="text-align:left">7</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td style="text-align:left">8</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-copyvalueof.html" target="_blank" rel="noopener">static String copyValueOf(char[] data, int offset, int count)</a> 返回指定数组中表示该字符序列的 String。</td>
</tr>
<tr>
<td style="text-align:left">9</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-endswith.html" target="_blank" rel="noopener">boolean endsWith(String suffix)</a> 测试此字符串是否以指定的后缀结束。</td>
</tr>
<tr>
<td style="text-align:left">10</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-equals.html" target="_blank" rel="noopener">boolean equals(Object anObject)</a> 将此字符串与指定的对象比较。</td>
</tr>
<tr>
<td style="text-align:left">11</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-equalsignorecase.html" target="_blank" rel="noopener">boolean equalsIgnoreCase(String anotherString)</a> 将此 String 与另一个 String 比较，不考虑大小写。</td>
</tr>
<tr>
<td style="text-align:left">12</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes()</a>  使用平台的默认字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td style="text-align:left">13</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-getbytes.html" target="_blank" rel="noopener">byte[] getBytes(String charsetName)</a> 使用指定的字符集将此 String 编码为 byte 序列，并将结果存储到一个新的 byte 数组中。</td>
</tr>
<tr>
<td style="text-align:left">14</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-getchars.html" target="_blank" rel="noopener">void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)</a> 将字符从此字符串复制到目标字符数组。</td>
</tr>
<tr>
<td style="text-align:left">15</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-hashcode.html" target="_blank" rel="noopener">int hashCode()</a> 返回此字符串的哈希码。</td>
</tr>
<tr>
<td style="text-align:left">16</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch)</a> 返回指定字符在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">17</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(int ch, int fromIndex)</a> 返回在此字符串中第一次出现指定字符处的索引，从指定的索引开始搜索。</td>
</tr>
<tr>
<td style="text-align:left">18</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str)</a>  返回指定子字符串在此字符串中第一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">19</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-indexof.html" target="_blank" rel="noopener">int indexOf(String str, int fromIndex)</a> 返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始。</td>
</tr>
<tr>
<td style="text-align:left">20</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-intern.html" target="_blank" rel="noopener">String intern()</a>  返回字符串对象的规范化表示形式。</td>
</tr>
<tr>
<td style="text-align:left">21</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch)</a>  返回指定字符在此字符串中最后一次出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">22</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(int ch, int fromIndex)</a> 返回指定字符在此字符串中最后一次出现处的索引，从指定的索引处开始进行反向搜索。</td>
</tr>
<tr>
<td style="text-align:left">23</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str)</a> 返回指定子字符串在此字符串中最右边出现处的索引。</td>
</tr>
<tr>
<td style="text-align:left">24</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-lastindexof.html" target="_blank" rel="noopener">int lastIndexOf(String str, int fromIndex)</a>  返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索。</td>
</tr>
<tr>
<td style="text-align:left">25</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-length.html" target="_blank" rel="noopener">int length()</a> 返回此字符串的长度。</td>
</tr>
<tr>
<td style="text-align:left">26</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-matches.html" target="_blank" rel="noopener">boolean matches(String regex)</a> 告知此字符串是否匹配给定的正则表达式。</td>
</tr>
<tr>
<td style="text-align:left">27</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td style="text-align:left">28</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-regionmatches.html" target="_blank" rel="noopener">boolean regionMatches(int toffset, String other, int ooffset, int len)</a> 测试两个字符串区域是否相等。</td>
</tr>
<tr>
<td style="text-align:left">29</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-replace.html" target="_blank" rel="noopener">String replace(char oldChar, char newChar)</a> 返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 得到的。</td>
</tr>
<tr>
<td style="text-align:left">30</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-replaceall.html" target="_blank" rel="noopener">String replaceAll(String regex, String replacement)</a> 使用给定的 replacement 替换此字符串所有匹配给定的正则表达式的子字符串。</td>
</tr>
<tr>
<td style="text-align:left">31</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-replacefirst.html" target="_blank" rel="noopener">String replaceFirst(String regex, String replacement)</a>  使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</td>
</tr>
<tr>
<td style="text-align:left">32</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex)</a> 根据给定正则表达式的匹配拆分此字符串。</td>
</tr>
<tr>
<td style="text-align:left">33</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-split.html" target="_blank" rel="noopener">String[] split(String regex, int limit)</a> 根据匹配给定的正则表达式来拆分此字符串。</td>
</tr>
<tr>
<td style="text-align:left">34</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix)</a> 测试此字符串是否以指定的前缀开始。</td>
</tr>
<tr>
<td style="text-align:left">35</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-startswith.html" target="_blank" rel="noopener">boolean startsWith(String prefix, int toffset)</a> 测试此字符串从指定索引开始的子字符串是否以指定前缀开始。</td>
</tr>
<tr>
<td style="text-align:left">36</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-subsequence.html" target="_blank" rel="noopener">CharSequence subSequence(int beginIndex, int endIndex)</a>  返回一个新的字符序列，它是此序列的一个子序列。</td>
</tr>
<tr>
<td style="text-align:left">37</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex)</a> 返回一个新的字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td style="text-align:left">38</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-substring.html" target="_blank" rel="noopener">String substring(int beginIndex, int endIndex)</a> 返回一个新字符串，它是此字符串的一个子字符串。</td>
</tr>
<tr>
<td style="text-align:left">39</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-tochararray.html" target="_blank" rel="noopener">char[] toCharArray()</a> 将此字符串转换为一个新的字符数组。</td>
</tr>
<tr>
<td style="text-align:left">40</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td style="text-align:left">41</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-tolowercase.html" target="_blank" rel="noopener">String toLowerCase(Locale locale)</a>  使用给定 Locale 的规则将此 String 中的所有字符都转换为小写。</td>
</tr>
<tr>
<td style="text-align:left">42</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-tostring.html" target="_blank" rel="noopener">String toString()</a>  返回此对象本身（它已经是一个字符串！）。</td>
</tr>
<tr>
<td style="text-align:left">43</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase()</a> 使用默认语言环境的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td style="text-align:left">44</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-touppercase.html" target="_blank" rel="noopener">String toUpperCase(Locale locale)</a> 使用给定 Locale 的规则将此 String 中的所有字符都转换为大写。</td>
</tr>
<tr>
<td style="text-align:left">45</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-trim.html" target="_blank" rel="noopener">String trim()</a> 返回字符串的副本，忽略前导空白和尾部空白。</td>
</tr>
<tr>
<td style="text-align:left">46</td>
<td style="text-align:left"><a href="https://www.runoob.com/java/java-string-valueof.html" target="_blank" rel="noopener">static String valueOf(primitive data type x)</a> 返回给定data type类型x参数的字符串表示形式。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="3-1-字符串的不可变性"><a href="#3-1-字符串的不可变性" class="headerlink" title="3.1 字符串的不可变性"></a>3.1 字符串的不可变性</h5><p><strong>定义一个字符串</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"abcd"</span>;</span><br></pre></td></tr></table></figure>
<p><a href="https://camo.githubusercontent.com/5fcf9d95e387567edb42c53a7414c079fb2073b6/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f537472696e672d496d6d75746162696c6974792d312e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5fcf9d95e387567edb42c53a7414c079fb2073b6/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f537472696e672d496d6d75746162696c6974792d312e6a706567" alt="String-Immutability-1"></a></p>
<p><code>s</code>中保存了string对象的引用。下面的箭头可以理解为“存储他的引用”。</p>
<p><strong>使用变量来赋值变量</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s2 = s;</span><br></pre></td></tr></table></figure>
<p><a href="https://camo.githubusercontent.com/475b2edd460884ff20b6f86c982848a69639fefc/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f537472696e672d496d6d75746162696c6974792d322e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/475b2edd460884ff20b6f86c982848a69639fefc/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f537472696e672d496d6d75746162696c6974792d322e6a706567" alt="String-Immutability-2"></a></p>
<p>s2保存了相同的引用值，因为他们代表同一个对象。</p>
<p><strong>字符串连接</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = s.concat(<span class="string">"ef"</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://camo.githubusercontent.com/ad36300358475cfeb8563424adecb1760e9ddc84/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f737472696e672d696d6d75746162696c6974792d363530783237392e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ad36300358475cfeb8563424adecb1760e9ddc84/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323030392f30322f737472696e672d696d6d75746162696c6974792d363530783237392e6a706567" alt="string-immutability"></a></p>
<p><code>s</code>中保存的是一个重新创建出来的string对象的引用。</p>
<p><strong>总结</strong></p>
<p>一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。</p>
<p>如果你需要一个可修改的字符串，应该使用StringBuffer 或者 StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。</p>
<p><strong>3.2 JDK 6和JDK 7中的substring的原理及区别</strong></p>
<p>String是Java中一个比较基础的类，每一个开发人员都会经常接触到。而且，String也是面试中经常会考的知识点。String有很多方法，有些方法比较常用，有些方法不太常用。今天要介绍的subString就是一个比较常用的方法，而且围绕subString也有很多面试题。</p>
<p><code>substring(int beginIndex, int endIndex)</code>方法在不同版本的JDK中的实现是不同的。了解他们的区别可以帮助你更好的使用他。为简单起见，后文中用<code>substring()</code>代表<code>substring(int beginIndex, int endIndex)</code>方法。</p>
<p><strong>substring() 的作用</strong></p>
<p><code>substring(int beginIndex, int endIndex)</code>方法截取字符串并返回其[beginIndex,endIndex-1]范围内的内容。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String x = <span class="string">"abcdef"</span>;</span><br><span class="line">x = x.substring(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure>
<p>输出内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc</span><br></pre></td></tr></table></figure>
<p><strong>调用substring()时发生了什么？</strong></p>
<p>你可能知道，因为x是不可变的，当使用<code>x.substring(1,3)</code>对x赋值的时候，它会指向一个全新的字符串：</p>
<p><a href="https://camo.githubusercontent.com/1147adecbaf28174f0fba78bd1a8e14a8ea8ab56/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d696d6d75746162696c697479312d363530783330332e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1147adecbaf28174f0fba78bd1a8e14a8ea8ab56/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d696d6d75746162696c697479312d363530783330332e6a706567" alt="string-immutability1"></a></p>
<p>然而，这个图不是完全正确的表示堆中发生的事情。因为在jdk6 和 jdk7中调用substring时发生的事情并不一样。</p>
<p><strong>JDK 6中的substring</strong></p>
<p>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：<code>char value[]</code>， <code>int offset</code>，<code>int count</code>。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。</p>
<p>当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。</p>
<p><a href="https://camo.githubusercontent.com/23eaeaa9e84d9fe6170350bf935dc5cf27f74e18/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d737562737472696e672d6a646b362d363530783338392e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/23eaeaa9e84d9fe6170350bf935dc5cf27f74e18/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d737562737472696e672d6a646b362d363530783338392e6a706567" alt="string-substring-jdk6"></a></p>
<p>下面是证明上说观点的Java源码中的关键代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 6</span></span><br><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">return</span>  <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>JDK 6中的substring导致的问题</strong></p>
<p>如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure>
<p>关于JDK 6中subString的使用不当会导致内存系列已经被官方记录在Java Bug Database中：</p>
<p><a href="https://camo.githubusercontent.com/3e917e690c48247e94bbe8af029df1b2a7ade4b8/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f6c65616b2e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3e917e690c48247e94bbe8af029df1b2a7ade4b8/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f6c65616b2e706e67" alt="leak"></a></p>
<blockquote>
<p>内存泄露：在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存。 内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
</blockquote>
<p><strong>JDK 7 中的substring</strong></p>
<p>上面提到的问题，在jdk 7中得到解决。在jdk 7 中，substring方法会在堆内存中创建一个新的数组。</p>
<p><a href="https://camo.githubusercontent.com/2c632253df0b4d5f7034898c618d47d1605f3722/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d737562737472696e672d6a646b37312d363530783338392e6a706567" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/2c632253df0b4d5f7034898c618d47d1605f3722/687474703a2f2f7777772e70726f6772616d637265656b2e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031332f30392f737472696e672d737562737472696e672d6a646b37312d363530783338392e6a706567" alt="string-substring-jdk7"></a></p>
<p>Java源码中关于这部分的主要代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK 7</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset + count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//check boundary</span></span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是JDK 7中的subString方法，其使用<code>new String</code>创建了一个新字符串，避免对老字符串的引用。从而解决了内存泄露问题。</p>
<p>所以，如果你的生产环境中使用的JDK版本小于1.7，当你使用String的subString方法时一定要注意，避免内存泄露。</p>
<h5 id="3-3-java中replace、replaceFirst和replaceAll区别"><a href="#3-3-java中replace、replaceFirst和replaceAll区别" class="headerlink" title="3.3 java中replace、replaceFirst和replaceAll区别"></a>3.3 java中replace、replaceFirst和replaceAll区别</h5><p>replace和replaceAll是JAVA中常用的替换字符的方法,它们的区别是:<br>　　1)replace的参数是char和CharSequence,即可以支持字符的替换,也支持字符串的替换(CharSequence即字符串序列的意思,说白了也就是字符串);<br>　　2)replaceAll的参数是regex,即基于规则表达式的替换,比如,可以通过replaceAll(“\\d”, “*”)把一个字符串所有的数字字符都换成星号;<br>　　相同点是都是全部替换,即把源字符串中的某一字符或字符串全部换成指定的字符或字符串,如果只想替换第一次出现的,可以使用 replaceFirst(),这个方法也是基于规则表达式的替换,但与replaceAll()不同的是,只替换第一次出现的字符串;<br>　　另外,如果replaceAll()和replaceFirst()所用的参数据不是基于规则表达式的,则与replace()替换字符串的效果是一样的,即这两者也支持字符串的操作;<br>　　还有一点注意:执行了替换操作后,源字符串的内容是没有发生改变的.<br>　　举例如下:
　　</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String src = <span class="keyword">new</span> String(<span class="string">"ab43a2c43d"</span>);</span><br><span class="line">　　System.out.println(src.replace(<span class="string">"3"</span>,<span class="string">"f"</span>));=&gt;ab4f2c4fd.</span><br><span class="line">　　System.out.println(src.replace(<span class="string">'3'</span>,<span class="string">'f'</span>));=&gt;ab4f2c4fd.</span><br><span class="line">　　System.out.println(src.replaceAll(<span class="string">"\\d"</span>,<span class="string">"f"</span>));=&gt;abffafcffd</span><br><span class="line">　　System.out.println(src.replaceAll(<span class="string">"a"</span>,<span class="string">"f"</span>));=&gt;fb43fc23d.</span><br><span class="line">　　System.out.println(src.replaceFirst(<span class="string">"\\d,"</span>f<span class="string">"));=&gt;abf32c43d</span></span><br><span class="line"><span class="string">　　System.out.println(src.replaceFirst("</span><span class="number">4</span><span class="string">","</span>h<span class="string">"));=&gt;abh32c43d.</span></span><br></pre></td></tr></table></figure>
<p>如何将字符串中的”\”替换成”\\”：
　　</p>
<p>String msgIn;
　　</p>
<p>String msgOut;
　　</p>
<p>msgOut=msgIn.replaceAll(“\\\\”,”\\\\\\\\”);
　　</p>
<p>原因：
　　</p>
<p>‘\’在java中是一个转义字符，所以需要用两个代表一个。例如System.out.println( “\\” ) ;只打印出一个”\”。但是’\’也是正则表达式中的转义字符（replaceAll 的参数就是正则表达式），需要用两个代表一个。所以：\\\\被java转换成\\,\\又被正则表达式转换成\。<br>　　同样<br>　　CODE: \\\\\\\\<br>　　Java: \\\\<br>　　Regex: \\<br>　　将字符串中的’/‘替换成’\’的几种方式:
　　</p>
<p>msgOut= msgIn.replaceAll(“/“, “\\\\”);
　　</p>
<p>msgOut= msgIn.replace(“/“, “\\”);
　　</p>
<p>msgOut= msgIn.replace(‘/‘, ‘\\’);</p>
<h5 id="3-4-String对”-”的重载"><a href="#3-4-String对”-”的重载" class="headerlink" title="3.4 String对”+”的重载"></a>3.4 String对”+”的重载</h5><ol>
<li>String s = “a” + “b”，编译器会进行常量折叠(因为两个都是编译期常量，编译期可知)，即变成 String s = “ab”</li>
<li>对于能够进行优化的(String s = “a” + 变量 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 (底层就是一个 new String())</li>
</ol>
<h5 id="3-5-字符串拼接的几种方式和区别"><a href="#3-5-字符串拼接的几种方式和区别" class="headerlink" title="3.5 字符串拼接的几种方式和区别"></a>3.5 字符串拼接的几种方式和区别</h5><p>字符串，是Java中最常用的一个数据类型了。</p>
<p>本文，也是对于Java中字符串相关知识的一个补充，主要来介绍一下字符串拼接相关的知识。本文基于jdk1.8.0_181。</p>
<p><strong>字符串拼接</strong></p>
<p>字符串拼接是我们在Java代码中比较经常要做的事情，就是把多个字符串拼接到一起。</p>
<p>我们都知道，<strong>String是Java中一个不可变的类</strong>，所以他一旦被实例化就无法被修改。</p>
<blockquote>
<p><strong>不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，比如可以缓存hashcode、使用更加便利以及更加安全等。</strong></p>
</blockquote>
<p>但是，既然字符串是不可变的，那么字符串拼接又是怎么回事呢？</p>
<p><strong>字符串不变性与字符串拼接</strong></p>
<p>其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。下面一段字符串拼接代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"abcd"</span>;</span><br><span class="line">s = s.concat(<span class="string">"ef"</span>);</span><br></pre></td></tr></table></figure>
<p>其实最后我们得到的s已经是一个新的字符串了。如下图</p>
<p><a href="https://camo.githubusercontent.com/60e15b7596ac3c8b80770f189fd003707da47c0b/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30312f31353437323839373930383339312e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/60e15b7596ac3c8b80770f189fd003707da47c0b/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30312f31353437323839373930383339312e6a7067" alt="img"></a>￼</p>
<p>s中保存的是一个重新创建出来的String对象的引用。</p>
<p>那么，在Java中，到底如何进行字符串拼接呢？字符串拼接有很多种方式，这里简单介绍几种比较常用的。</p>
<p><strong>使用+拼接字符串</strong></p>
<p>在Java中，拼接字符串最简单的方式就是直接使用符号<code>+</code>来拼接。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat + <span class="string">","</span> + introduce;</span><br></pre></td></tr></table></figure>
<p>这里要特别说明一点，有人把Java中使用<code>+</code>拼接字符串的功能理解为<strong>运算符重载</strong>。其实并不是，<strong>Java是不支持运算符重载的</strong>。这其实只是Java提供的一个<strong>语法糖</strong>。后面再详细介绍。</p>
<blockquote>
<p><strong>运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。</strong></p>
<p><strong>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</strong></p>
</blockquote>
<p><strong>concat</strong><br>除了使用<code>+</code>拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat.concat(<span class="string">","</span>).concat(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringBuffer</strong></p>
<p>关于字符串，Java中除了定义了一个可以用来定义<strong>字符串常量</strong>的<code>String</code>类以外，还提供了可以用来定义<strong>字符串变量</strong>的<code>StringBuffer</code>类，它的对象是可以扩充和修改的。</p>
<p>使用<code>StringBuffer</code>可以方便的对字符串进行拼接。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuffer wechat = <span class="keyword">new</span> StringBuffer(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuffer hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringBuilder</strong><br>除了<code>StringBuffer</code>以外，还有一个类<code>StringBuilder</code>也可以使用，其用法和<code>StringBuffer</code>类似。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder wechat = <span class="keyword">new</span> StringBuilder(<span class="string">"Hollis"</span>);</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">StringBuilder hollis = wechat.append(<span class="string">","</span>).append(introduce);</span><br></pre></td></tr></table></figure>
<p><strong>StringUtils.join</strong><br>除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如<code>apache.commons中</code>提供的<code>StringUtils</code>类，其中的<code>join</code>方法可以拼接字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">System.out.println(StringUtils.join(wechat, <span class="string">","</span>, introduce));</span><br></pre></td></tr></table></figure>
<p>这里简单说一下，StringUtils中提供的join方法，最主要的功能是：将数组或集合以某拼接符拼接到一起形成新的字符串，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String []list  =&#123;<span class="string">"Hollis"</span>,<span class="string">"每日更新Java相关技术文章"</span>&#125;;</span><br><span class="line">String result= StringUtils.join(list,<span class="string">","</span>);</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="comment">//结果：Hollis,每日更新Java相关技术文章</span></span><br></pre></td></tr></table></figure>
<p>并且，Java8中的String类中也提供了一个静态的join方法，用法和StringUtils.join类似。</p>
<p>以上就是比较常用的五种在Java种拼接字符串的方式，那么到底哪种更好用呢？为什么阿里巴巴Java开发手册中不建议在循环体中使用<code>+</code>进行字符串拼接呢？</p>
<p><a href="https://camo.githubusercontent.com/425258370f5e0a09ee0661f7f807b1bc200ee532/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30312f31353437323835303137303233302e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/425258370f5e0a09ee0661f7f807b1bc200ee532/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30312f31353437323835303137303233302e6a7067" alt="img"></a>￼</p>
<p>(阿里巴巴Java开发手册中关于字符串拼接的规约)</p>
<p><strong>使用<code>+</code>拼接字符串的实现原理</strong></p>
<p>前面提到过，使用<code>+</code>拼接字符串，其实只是Java提供的一个语法糖， 那么，我们就来解一解这个语法糖，看看他的内部原理到底是如何实现的。</p>
<p>还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"每日更新Java相关技术文章"</span>;</span><br><span class="line">String hollis = wechat + <span class="string">","</span> + introduce;</span><br></pre></td></tr></table></figure>
<p>反编译后的内容如下，反编译工具为jad。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String wechat = <span class="string">"Hollis"</span>;</span><br><span class="line">String introduce = <span class="string">"\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0"</span>;<span class="comment">//每日更新Java相关技术文章</span></span><br><span class="line">String hollis = (<span class="keyword">new</span> StringBuilder()).append(wechat).append(<span class="string">","</span>).append(introduce).toString();</span><br></pre></td></tr></table></figure>
<p>通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。</p>
<p>那么也就是说，Java中的<code>+</code>对字符串的拼接，其实现原理是使用<code>StringBuilder.append</code>。</p>
<p><strong>concat是如何实现的</strong></p>
<p>我们再来看一下concat方法的源代码，看一下这个方法又是如何实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。</p>
<p>通过源码我们也可以看到，经过concat方法，其实是new了一个新的String，这也就呼应到前面我们说的字符串的不变性问题上了。</p>
<p><strong>StringBuffer和StringBuilder</strong></p>
<p>接下来我们看看<code>StringBuffer</code>和<code>StringBuilder</code>的实现原理。</p>
<p>和<code>String</code>类类似，<code>StringBuilder</code>类也封装了一个字符数组，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] value;</span><br></pre></td></tr></table></figure>
<p>与<code>String</code>不同的是，它并不是<code>final</code>的，所以他是可以修改的。另外，与<code>String</code>不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure>
<p>其append源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该类继承了<code>AbstractStringBuilder</code>类，看下其<code>append</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。</p>
<p><code>StringBuffer</code>和<code>StringBuilder</code>类似，最大的区别就是<code>StringBuffer</code>是线程安全的，看一下<code>StringBuffer</code>的<code>append</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用<code>synchronized</code>进行声明，说明是一个线程安全的方法。而<code>StringBuilder</code>则不是线程安全的。</p>
<p><strong>StringUtils.join是如何实现的</strong></p>
<p>通过查看<code>StringUtils.join</code>的源代码，我们可以发现，其实他也是通过<code>StringBuilder</code>来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">join</span><span class="params">(<span class="keyword">final</span> Object[] array, String separator, <span class="keyword">final</span> <span class="keyword">int</span> startIndex, <span class="keyword">final</span> <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (separator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        separator = EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// endIndex - startIndex &gt; 0:   Len = NofStrings *(len(firstString) + len(separator))</span></span><br><span class="line">    <span class="comment">//           (Assuming that all Strings are roughly equally long)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> noOfItems = endIndex - startIndex;</span><br><span class="line">    <span class="keyword">if</span> (noOfItems &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StringBuilder buf = <span class="keyword">new</span> StringBuilder(noOfItems * <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; endIndex; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; startIndex) &#123;</span><br><span class="line">            buf.append(separator);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (array[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.append(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> buf.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效率比较</strong></p>
<p>既然有这么多种字符串拼接的方法，那么到底哪一种效率最高呢？我们来简单对比一下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line"><span class="comment">//这里是初始字符串定义</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//这里是字符串拼接代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"cost:"</span> + (t2 - t1));</span><br></pre></td></tr></table></figure>
<p>我们使用形如以上形式的代码，分别测试下五种字符串拼接代码的运行时间。得到结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ cost:<span class="number">5119</span></span><br><span class="line">StringBuilder cost:<span class="number">3</span></span><br><span class="line">StringBuffer cost:<span class="number">4</span></span><br><span class="line">concat cost:<span class="number">3623</span></span><br><span class="line">StringUtils.join cost:<span class="number">25726</span></span><br></pre></td></tr></table></figure>
<p>从结果可以看出，用时从短到长的对比是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder`&lt;`StringBuffer`&lt;`concat`&lt;`+`&lt;`StringUtils.join</span><br></pre></td></tr></table></figure>
<p><code>StringBuffer</code>在<code>StringBuilder</code>的基础上，做了同步处理，所以在耗时上会相对多一些。</p>
<p>StringUtils.join也是使用了StringBuilder，并且其中还是有很多其他操作，所以耗时较长，这个也容易理解。其实StringUtils.join更擅长处理字符串数组或者列表的拼接。</p>
<p>那么问题来了，前面我们分析过，其实使用<code>+</code>拼接字符串的实现原理也是使用的<code>StringBuilder</code>，那为什么结果相差这么多，高达1000多倍呢？</p>
<p>我们再把以下代码反编译下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str += s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"+ cost:"</span> + (t2 - t1));</span><br></pre></td></tr></table></figure>
<p>反编译后代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> t1 = System.currentTimeMillis();</span><br><span class="line">String str = <span class="string">"hollis"</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String s = String.valueOf(i);</span><br><span class="line">    str = (<span class="keyword">new</span> StringBuilder()).append(str).append(s).toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> t2 = System.currentTimeMillis();</span><br><span class="line">System.out.println((<span class="keyword">new</span> StringBuilder()).append(<span class="string">"+ cost:"</span>).append(t2 - t1).toString());</span><br></pre></td></tr></table></figure>
<p>我们可以看到，反编译后的代码，在<code>for</code>循环中，每次都是<code>new</code>了一个<code>StringBuilder</code>，然后再把<code>String</code>转成<code>StringBuilder</code>，再进行<code>append</code>。</p>
<p>而频繁的新建对象当然要耗费很多时间了，不仅仅会耗费时间，频繁的创建对象，还会造成内存资源的浪费。</p>
<p>所以，阿里巴巴Java开发手册建议：循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。而不要使用<code>+</code>。</p>
<p><strong>总结</strong></p>
<p>本文介绍了什么是字符串拼接，虽然字符串是不可变的，但是还是可以通过新建字符串的方式来进行字符串的拼接。</p>
<p>常用的字符串拼接方式有五种，分别是使用<code>+</code>、使用<code>concat</code>、使用<code>StringBuilder</code>、使用<code>StringBuffer</code>以及使用<code>StringUtils.join</code>。</p>
<p>由于字符串拼接过程中会创建新的对象，所以如果要在一个循环体中进行字符串拼接，就要考虑内存问题和效率问题。</p>
<p>因此，经过对比，我们发现，直接使用<code>StringBuilder</code>的方式是效率最高的。因为<code>StringBuilder</code>天生就是设计来定义可变字符串和字符串的变化操作的。</p>
<p>但是，还要强调的是：</p>
<p>1、如果不是在循环体中进行字符串拼接的话，直接使用<code>+</code>就好了。</p>
<p>2、如果在并发场景中进行字符串拼接的话，要使用<code>StringBuffer</code>来代替<code>StringBuilder</code>。</p>
<h5 id="3-6-String-valueOf和Integer-toString的区别"><a href="#3-6-String-valueOf和Integer-toString的区别" class="headerlink" title="3.6 String.valueOf和Integer.toString的区别"></a>3.6 String.valueOf和Integer.toString的区别</h5><p>我们有三种方式将一个int类型的变量变成呢过String类型，那么他们有什么区别？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.<span class="keyword">int</span> i = <span class="number">5</span>;</span><br><span class="line"><span class="number">2</span>.String i1 = <span class="string">""</span> + i;</span><br><span class="line"><span class="number">3</span>.String i2 = String.valueOf(i);</span><br><span class="line"><span class="number">4</span>.String i3 = Integer.toString(i);</span><br></pre></td></tr></table></figure>
<p>第三行和第四行没有任何区别，因为String.valueOf(i)也是调用Integer.toString(i)来实现的。</p>
<p>第二行代码其实是String i1 = (new StringBuilder()).append(i).toString();，首先创建一个StringBuilder对象，然后再调用append方法，再调用toString方法。</p>
<h5 id="3-7-switch对String的支持"><a href="#3-7-switch对String的支持" class="headerlink" title="3.7 switch对String的支持"></a>3.7 switch对String的支持</h5><p>Java 7中，switch的参数可以是String类型了，这对我们来说是一个很方便的改进。到目前为止switch支持这样几种数据类型：<code>byte</code> <code>short</code> <code>int</code> <code>char</code> <code>String</code> 。但是，作为一个程序员我们不仅要知道他有多么好用，还要知道它是如何实现的，switch对整型的支持是怎么实现的呢？对字符型是怎么实现的呢？String类型呢？有一点Java开发经验的人这个时候都会猜测switch对String的支持是使用equals()方法和hashcode()方法。那么到底是不是这两个方法呢？接下来我们就看一下，switch到底是如何实现的。</p>
<p><strong>switch对整型支持的实现</strong></p>
<p>下面是一段很简单的Java代码，定义一个int型变量a，然后使用switch语句进行判断。执行这段代码输出内容为5，那么我们将下面这段代码反编译，看看他到底是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            System.out.println(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output 5</span></span><br></pre></td></tr></table></figure>
<p>反编译后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoInt</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">switchDemoInt</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">// '\001'</span></span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: <span class="comment">// '\005'</span></span><br><span class="line">            System.out.println(<span class="number">5</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，反编译后的代码和之前的代码比较除了多了两行注释以外没有任何区别，那么我们就知道，<strong>switch对int的判断是直接比较整数的值</strong>。</p>
<p><strong>switch对字符型支持的实现</strong></p>
<p>直接上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoInt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'b'</span>;</span><br><span class="line">        <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">            System.out.println(<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'b'</span>:</span><br><span class="line">            System.out.println(<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译后的代码如下： `public class switchDemoChar</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoChar</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">switchDemoChar</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> a = <span class="string">'b'</span>;</span><br><span class="line">        <span class="keyword">switch</span>(a)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">97</span>: <span class="comment">// 'a'</span></span><br><span class="line">            System.out.println(<span class="string">'a'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">98</span>: <span class="comment">// 'b'</span></span><br><span class="line">            System.out.println(<span class="string">'b'</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上的代码作比较我们发现：对char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量</p>
<p><strong>switch对字符串支持的实现</strong></p>
<p>还是先上代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"hello"</span>:</span><br><span class="line">            System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">            System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对代码进行反编译：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">switchDemoString</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">switchDemoString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String str = <span class="string">"world"</span>;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">switch</span>((s = str).hashCode())</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                System.out.println(<span class="string">"world"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这个代码，你知道原来字符串的switch是通过<code>equals()</code>和<code>hashCode()</code>方法来实现的。<strong>记住，switch中只能使用整型</strong>，比如<code>byte</code>。<code>short</code>，<code>char</code>(ackii码是整型)以及<code>int</code>。还好<code>hashCode()</code>方法返回的是<code>int</code>，而不是<code>long</code>。通过这个很容易记住<code>hashCode</code>返回的是<code>int</code>这个事实。仔细看下可以发现，进行<code>switch</code>的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个<code>equals</code>方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把<code>hashCode()</code>方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个<code>switch</code>语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里<code>hashCode()</code>方法的调用开销其实不会很大。</p>
<p>好，以上就是关于switch对整型、字符型、和字符串型的支持的实现方式，总结一下我们可以发现，<strong>其实switch只支持一种数据类型，那就是整型，其他数据类型都是转换成整型之后在使用switch的。</strong></p>
<h5 id="3-8-字符串常量池、运行时常量池"><a href="#3-8-字符串常量池、运行时常量池" class="headerlink" title="3.8 字符串常量池、运行时常量池"></a><strong>3.8 字符串常量池、运行时常量池</strong></h5><p>众所周知，在JVM中栈存放对象的引用和基本类型，堆存放具体的对象和每个对象包含一个与之对应的class信息，方法区存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p>
<p>关于String常量池、常量池等又让人头大。</p>
<p>String str = “abc”; 如此生成的字符串存放在常量池中</p>
<p>String str = new String(“abc”); 如此生成的字符串存放在堆中</p>
<p>现在分析一下常量池的相关知识：</p>
<h5 id="1-字符串常量池在Java内存区域的哪个位置？"><a href="#1-字符串常量池在Java内存区域的哪个位置？" class="headerlink" title="1.字符串常量池在Java内存区域的哪个位置？"></a><strong>1.字符串常量池在Java内存区域的哪个位置？</strong></h5><ul>
<li>在JDK6.0及之前版本，字符串常量池是放在Perm Gen区(也就是方法区)中；</li>
<li>在JDK7.0版本，字符串常量池被移到了堆中了。</li>
</ul>
<p><strong>2.字符串常量池里放的是什么？</strong></p>
<ul>
<li>在JDK6.0及之前版本中，String Pool里放的都是字符串常量；</li>
<li>JDK7.0中，String Pool中也可以存放放于堆内的字符串对象的引用。</li>
</ul>
<h5 id="3-运行时常量池-Runtime-Constant-Pool-："><a href="#3-运行时常量池-Runtime-Constant-Pool-：" class="headerlink" title="3.运行时常量池(Runtime Constant Pool)："></a><strong>3.运行时常量池(Runtime Constant Pool)：</strong></h5><ul>
<li>运行时常量池存在于内存中，也就是class常量池被加载到内存之后的版本，不同之处是：它的字面量可以动态的添加，符号引用可以被解析为直接引用</li>
<li>JVM在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在解析阶段，会把符号引用替换为直接引用，解析的过程会去查询字符串常量池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与字符串常量池中是一致的。</li>
</ul>
<h5 id="3-9-JAVA关键字"><a href="#3-9-JAVA关键字" class="headerlink" title="3.9 JAVA关键字"></a><strong>3.9 JAVA关键字</strong></h5><p>1、static：</p>
<p>   static可以用来修饰class、field、method等，被static修饰的关键字都存在于堆内存中，也即其生命周期一般是整个应用生命周期，static修饰的field又叫做全局变量，可以在整个类包括其子类中被使用，static修饰的class一般用于静态内部类，是一个类的静态成员，外部可以直接通过类名.静态内部类名来访问，可用new关键字，保证该类所有实例共享一个内存空间；static修饰method，可以不用该方法所属类的实例，直接通过该方法名调用该方法，该方法作为一个对象存放在堆内存中的静态方法区。</p>
<p>2、final：</p>
<p>可以用来修饰class、field、method，final关键字的作用表明该field或class是一个常量，只能进行一次初始化。</p>
<p>3、volatile：</p>
<p>   一般用于修饰field，保证改数据的内存可见性以及防止jvm对指令进行重排，其原理是：线程A中，cpu执行修改改field时，会先将各种数据加入计算机的缓存中，执行完了后，在写回缓存里面，最后在某个时间，对应线程再读回到主存中，但这样会导致内存可见性安全问题。使用volatile关键字，保证了每个线程都会从主存中去读取该field的值，执行完成后再写回主存中，而不经过缓存，以此来保证线程安全。</p>
<p>4、synchronized：</p>
<p>  该关键字一般用于保证线程安全，可以直接修饰class的某个实例、class、method、field等，修饰class的某个实例表示，获取这个实例的对应monitor，只有该monitor没有被其他线程占用时，才可以进入该代码段，修饰class或static时，表示这一类的所有实例都只能同时有一个线程进行访问。修饰field和method和修饰实例差不多。</p>
<p>5、transient：</p>
<p>  此关键字修饰的field表示该field被序列化时，此对象的值不可见，只存在于当前内存中。</p>
<p>6、strictfp</p>
<p>浮点精度统一，用来修饰类、接口或方法，以此来限制该类的所有float和double都遵循统一的IEEE 754 标准，在不同的操作系统平台环境下都产生同样的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/16/JAVA基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/16/JAVA基础篇/" itemprop="url">JAVA基础篇（一）—面向对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-16T14:14:50+08:00">
                2019-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、面向对象"><a href="#一、面向对象" class="headerlink" title="一、面向对象"></a>一、面向对象</h3><h4 id="1、面向过程和面向对象"><a href="#1、面向过程和面向对象" class="headerlink" title="1、面向过程和面向对象"></a>1、面向过程和面向对象</h4><blockquote>
<p>什么是面向过程？<br>概述: 自顶而下的编程模式.</p>
</blockquote>
<p>把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。</p>
<p>就是说，在进行面向过程编程的时候，不需要考虑那么多，上来先定义一个函数，然后使用各种诸如if-else、for-each等方式进行代码执行。</p>
<p>最典型的用法就是实现一个简单的算法，比如实现冒泡排序。</p>
<blockquote>
<p>什么是面向对象？<br>概述: 将事务高度抽象化的编程模式.</p>
</blockquote>
<p>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p>
<p>比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p>
<hr>
<p>举例说明区别<br>同样一个象棋设计.</p>
<p>面向对象:创建黑白双方的对象负责演算,棋盘的对象负责画布,规则的对象负责判断，例子可以看出,面向对象更重视不重复造轮子,即创建一次,重复使用.</p>
<p>面向过程:开始—黑走—棋盘—判断—白走—棋盘—判断—循环。只需要关注每一步怎么实现即可.</p>
<p>优劣对比</p>
<p>面向对象:占用资源相对高,速度相对慢</p>
<p>面向过程:占用资源相对低,速度相对快</p>
<h4 id="2、面向对象三大特征和五大原则"><a href="#2、面向对象三大特征和五大原则" class="headerlink" title="2、面向对象三大特征和五大原则"></a>2、面向对象三大特征和五大原则</h4><h5 id="面向对象三大特征："><a href="#面向对象三大特征：" class="headerlink" title="面向对象三大特征："></a>面向对象三大特征：</h5><p><strong>(1)封装(Encapsulation)</strong></p>
<p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<p><strong>(2)继承(Inheritance)</strong></p>
<p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；</p>
<p><strong>(3)多态(Polymorphism)</strong></p>
<p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。<br>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</p>
<h5 id="面向对象五大原则："><a href="#面向对象五大原则：" class="headerlink" title="面向对象五大原则："></a>面向对象五大原则：</h5><p><strong>单一职责原则（Single-Resposibility Principle）</strong></p>
<p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。 专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。</p>
<p><strong>开放封闭原则（Open-Closed principle）</strong></p>
<p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。 实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 “需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。</p>
<p><strong>Liskov替换原则（Liskov-Substitution Principle）</strong></p>
<p>其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。 Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。 Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p>
<p><strong>依赖倒置原则（Dependecy-Inversion Principle）</strong></p>
<p>其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。 抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p>
<p><strong>接口隔离原则（Interface-Segregation Principle）</strong></p>
<p>其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖接口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是“浪费”，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖于它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。 分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>
<p>以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”</p>
<h4 id="3、平台无关性"><a href="#3、平台无关性" class="headerlink" title="3、平台无关性"></a>3、平台无关性</h4><h5 id="java如何实现平台无关性"><a href="#java如何实现平台无关性" class="headerlink" title="java如何实现平台无关性"></a>java如何实现平台无关性</h5><p>相信对于很多Java开发来说，在刚刚接触Java语言的时候，就听说过Java是一门跨平台的语言，Java是平台无关性的，这也是Java语言可以迅速崛起并风光无限的一个重要原因。那么，到底什么是平台无关性？Java又是如何实现平台无关性的呢？本文就来简单介绍一下。</p>
<p><strong>什么是平台无关性</strong></p>
<p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
<p><strong>平台无关性好处</strong></p>
<p>作为一门平台无关性语言，无论是在自身发展，还是对开发者的友好度上都是很突出的。</p>
<p>因为其平台无关性，所以Java程序可以运行在各种各样的设备上，尤其是一些嵌入式设备，如打印机、扫描仪、传真机等。随着5G时代的来临，也会有更多的终端接入网络，相信平台无关性的Java也能做出一些贡献。</p>
<p>对于Java开发者来说，Java减少了开发和部署到多个平台的成本和时间。真正的做到一次编译，到处运行。</p>
<p><strong>平台无关性的实现</strong></p>
<p>对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。</p>
<p><strong>编译原理基础</strong></p>
<p>讲到Java语言规范、Class文件、Java虚拟机就不得不提Java到底是是如何运行起来的。</p>
<p>我们在<a href="http://www.hollischuang.com/archives/58" target="_blank" rel="noopener">Java代码的编译与反编译那些事儿</a>中介绍过，在计算机世界中，计算机只认识0和1，所以，真正被计算机执行的其实是由0和1组成的二进制文件。</p>
<p>但是，我们日常开发使用的C、C++、Java、Python等都属于高级语言，而非二进制语言。所以，想要让计算机认识我们写出来的Java代码，那就需要把他”翻译”成由0和1组成的二进制文件。这个过程就叫做编译。负责这一过程的处理的工具叫做编译器。</p>
<p>在<a href="https://www.hollischuang.com/archives/2322" target="_blank" rel="noopener">深入分析Java的编译原理</a>中我们介绍过，在Java平台中，想要把Java文件，编译成二进制文件，需要经过两步编译，前端编译和后端编译：</p>
<p><a href="https://camo.githubusercontent.com/a023558e81a03776a8406c12f8410a259148e94e/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393238343736323434392e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a023558e81a03776a8406c12f8410a259148e94e/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393238343736323434392e6a7067" alt="img"></a>￼</p>
<p>前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的<code>javac</code>的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把<code>.java</code>代码转换成<code>.class</code>代码。</p>
<p>这里提到的<code>.class</code>代码，其实就是Class文件。</p>
<p>后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。</p>
<p><a href="https://camo.githubusercontent.com/74b6fcd571f3f860ce090abbba484c1c0582f09f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393238393533303234352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/74b6fcd571f3f860ce090abbba484c1c0582f09f/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393238393533303234352e6a7067" alt="img"></a>￼</p>
<p>所以，我们说的，Java的平台无关性实现主要作用于以上阶段。如下图所示：</p>
<p><a href="https://camo.githubusercontent.com/a2e2815a2d9ad21076fb0801e276a9cea93dfc2b/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393239313533333137352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/a2e2815a2d9ad21076fb0801e276a9cea93dfc2b/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393239313533333137352e6a7067" alt="img"></a>￼</p>
<p>我们从后往前介绍一下这三位主演：Java虚拟机、Class文件、Java语言规范</p>
<p><strong>Java虚拟机</strong></p>
<p>所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。</p>
<p>对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。</p>
<p>而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但是JVM确实平台有关的，不同的操作系统上面要安装对应的JVM。</p>
<p><a href="https://camo.githubusercontent.com/9cabf67695945eb4538b113ee85171615c10aa5c/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393239373038323032352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/9cabf67695945eb4538b113ee85171615c10aa5c/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393239373038323032352e6a7067" alt="img"></a>￼</p>
<p>上图是Oracle官网下载JDK的指引，不同的操作系统需要下载对应的Java虚拟机。</p>
<p>有了Java虚拟机，想要执行a+b操作，A操作系统上面的虚拟机就会把指令翻译成10001000，B操作系统上面的虚拟机就会把指令翻译成11101110。</p>
<p><a href="https://camo.githubusercontent.com/cb51cbd17106020934ff791fef9b82f0acb9a606/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393330333832393931342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/cb51cbd17106020934ff791fef9b82f0acb9a606/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393330333832393931342e6a7067" alt="img"></a>￼ ps：图中的Class文件中内容为mock内容</p>
<p>所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。</p>
<p><strong>字节码</strong></p>
<p>各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（ByteCode）是构成平台无关性的另一个基石。Java虚拟机只与由字节码组成的Class文件进行交互。</p>
<p>我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。</p>
<p>因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。</p>
<p><strong>Java语言规范</strong></p>
<p>已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？</p>
<p>其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。</p>
<p>比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C/C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。</p>
<p>举一个简单的例子，对于int类型，在Java中，int占4个字节，这是固定的。</p>
<p>但是在C++中却不是固定的了。在16位计算机上，int类型的长度可能为两字节；在32位计算机上，可能为4字节；当64位计算机流行起来后，int类型的长度可能会达到8字节。（这里说的都是可能哦！）</p>
<p><a href="https://camo.githubusercontent.com/642441dac9631c52fed33ffd5a4c0b195d72ca11/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393331393634353230352e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/642441dac9631c52fed33ffd5a4c0b195d72ca11/68747470733a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031392f30332f31353533393331393634353230352e6a7067" alt="img"></a>￼</p>
<p>通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。</p>
<p><strong>小结</strong></p>
<p>对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演着重要角色的有Java语言规范、Class文件、Java虚拟机等。</p>
<ul>
<li>Java语言规范<ul>
<li>通过规定Java语言中基本数据类型的取值范围和行为</li>
</ul>
</li>
<li>Class文件<ul>
<li>所有Java文件要编译成统一的Class文件</li>
</ul>
</li>
<li>Java虚拟机<ul>
<li>通过Java虚拟机将Class文件转成对应平台的二进制文件等</li>
</ul>
</li>
</ul>
<p>Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异。</p>
<p><strong>语言无关性</strong></p>
<p>其实，Java的无关性不仅仅体现在平台无关性上面，向外扩展一下，Java还具有语言无关性。</p>
<p>前面我们提到过。JVM其实并不是和Java文件进行交互的，而是和Class文件，也就是说，其实JVM运行的时候，并不依赖于Java语言。</p>
<p>时至今日，商业机构和开源机构已经在Java语言之外发展出一大批可以在JVM上运行的语言了，如Groovy、Scala、Jython等。之所以可以支持，就是因为这些语言也可以被编译成字节码（Class文锦啊）。而虚拟机并不关心字节码是有哪种语言编译而来的。详见<a href="https://www.hollischuang.com/archives/2938" target="_blank" rel="noopener">牛逼了，教你用九种语言在JVM上输出HelloWorld</a></p>
<h4 id="4、JVM还支持哪些语言"><a href="#4、JVM还支持哪些语言" class="headerlink" title="4、JVM还支持哪些语言"></a>4、JVM还支持哪些语言</h4><p>我们在《[深入分析Java的编译原理][1]》中提到过，为了让Java语言具有良好的跨平台能力，Java独具匠心的提供了一种可以在所有平台上都能使用的一种中间代码——字节码（ByteCode）。</p>
<p>有了字节码，无论是哪种平台（如Windows、Linux等），只要安装了虚拟机，都可以直接运行字节码。</p>
<p>同样，有了字节码，也解除了Java虚拟机和Java语言之间的耦合。这话可能很多人不理解，Java虚拟机不就是运行Java语言的么？这种解耦指的是什么？</p>
<p>其实，目前Java虚拟机已经可以支持很多除Java语言以外的语言了，如Kotlin、Groovy、JRuby、Jython、Scala等。之所以可以支持，就是因为这些语言也可以被编译成字节码。而虚拟机并不关心字节码是有哪种语言编译而来的。</p>
<p>经常使用IDE的开发者可能会发现，当我们在Intelij IDEA中，鼠标右键想要创建Java类的时候，IDE还会提示创建其他类型的文件，这就是IDE默认支持的一些可以运行在JVM上面的语言，没有提示的，可以通过插件来支持。</p>
<p><img src="https://www.hollischuang.com/wp-content/uploads/2018/11/languages.png" alt width="1102" height="372" class="aligncenter size-full wp-image-2968"></p>
<p>目前，可以直接在JVM上运行的语言有很多，今天介绍其中比较重要的九种。每种语言通过一段『HelloWorld』代码进行演示，看看不同语言的语法有何不同。</p>
<p><strong>Kotlin</strong></p>
<p>Kotlin是一种在Java虚拟机上运行的静态类型编程语言，它也可以被编译成为JavaScript源代码。Kotlin的设计初衷就是用来生产高性能要求的程序的，所以运行起来和Java也是不相上下。Kotlin可以从 JetBrains InteilliJ Idea IDE这个开发工具以插件形式使用。</p>
<p><strong>Hello World In Kotlin</strong></p>
<pre><code>fun main(args: Array&lt;String&gt;) {
    println(&quot;Hello, world!&quot;)
}
</code></pre><p><strong>Groovy</strong></p>
<p>Apache的Groovy是Java平台上设计的面向对象编程语言。它的语法风格与Java很像，Java程序员能够很快的熟练使用 Groovy，实际上，Groovy编译器是可以接受完全纯粹的Java语法格式的。</p>
<p>使用Groovy的一个重要特点就是使用类型推断，即能够让编译器能够在程序员没有明确说明的时候推断出变量的类型。Groovy可以使用其他Java语言编写的库。Groovy的语法与Java非常相似，大多数Java代码也匹配Groovy的语法规则，尽管可能语义不同。</p>
<p><strong>Hello World In Groovy</strong></p>
<pre><code>static void main(String[] args) {
    println(&#39;Hello, world!&#39;);
}
</code></pre><p><strong>Scala</strong></p>
<p>Scala是一门多范式的编程语言，设计初衷是要集成面向对象编程和函数式编程的各种特性。</p>
<p>Scala经常被我们描述为多模式的编程语言，因为它混合了来自很多编程语言的元素的特征。但无论如何它本质上还是一个纯粹的面向对象语言。它相比传统编 程语言最大的优势就是提供了很好并行编程基础框架措施了。Scala代码能很好的被优化成字节码，运行起来和原生Java一样快。</p>
<p><strong>Hello World In Scala</strong></p>
<pre><code>object HelloWorld {  
    def main(args: Array[String]) {  
       System.out.println(&quot;Hello, world!&quot;);  
    }  
 } 
</code></pre><p><strong>Jruby</strong></p>
<p>JRuby是用来桥接Java与Ruby的，它是使用比Groovy更加简短的语法来编写代码，能够让每行代码执行更多的任务。就和Ruby一样，JRuby不仅仅只提供了高级的语法格式。它同样提供了纯粹的面向对象的实现，闭包等等，而且JRuby跟Ruby自身相比多了很多基于Java类库 可以调用，虽然Ruby也有很多类库，但是在数量以及广泛性上是无法跟Java标准类库相比的。</p>
<p><strong>Hello World In Jruby</strong></p>
<pre><code>&quot;puts &#39;Hello, world!&#39;&quot;
</code></pre><p><strong>Jython</strong></p>
<p>Jython，是一个用Java语言写的Python解释器。Jython能够用Python语言来高效生成动态编译的Java字节码。</p>
<p><strong>Hello World In Jython</strong></p>
<pre><code>print &quot;Hello, world!&quot;
</code></pre><p><strong>Fantom</strong></p>
<p>Fantom是一种通用的面向对象编程语言，由Brian和Andy Frank创建，运行在Java Runtime Environment，JavaScript和.NET Common Language Runtime上。其主要设计目标是提供标准库API，以抽象出代码是否最终将在JRE或CLR上运行的问题。</p>
<p>Fantom是与Groovy以及JRuby差不多的一样面向对 象的编程语言，但是悲剧的是Fantom无法使用Java类库，而是使用它自己扩展的类库。</p>
<p><strong>Hello World In Fantom</strong></p>
<pre><code>class Hello
{
  static Void main() { echo(&quot;Hello, world!&quot;) }
}
</code></pre><p><strong>Clojure</strong></p>
<p>Clojure是Lisp编程语言在Java平台上的现代、函数式及动态方言。 与其他Lisp一样，Clojure视代码为数据且拥有一套Lisp宏系统。</p>
<p>虽然Clojure也能被直接编译成Java字节码，但是无法使用动态语言特性以及直 接调用Java类库。与其他的JVM脚本语言不一样，Clojure并不算是面向对象的。</p>
<p><strong>Hello World In Clojure</strong></p>
<pre><code>(defn -main [&amp; args]
    (println &quot;Hello, World!&quot;))
</code></pre><p><strong>Rhino</strong></p>
<p>Rhino是一个完全以Java编写的JavaScript引擎，目前由Mozilla基金会所管理。</p>
<p>Rhino的特点是为JavaScript加了个壳，然后嵌入到Java中，这样能够让Java程序员直接使用。其中Rhino的JavaAdapters能够让JavaScript通过调用Java的类来实现特定的功能。</p>
<p><strong>Hello World In Rhino</strong></p>
<pre><code> print(&#39;Hello, world!&#39;)
</code></pre><p><strong>Ceylon</strong></p>
<p>Ceylon是一种面向对象，强烈静态类型的编程语言，强调不变性，由Red Hat创建。 Ceylon程序在Java虚拟机上运行，可以编译为JavaScript。 语言设计侧重于源代码可读性，可预测性，可扩展性，模块性和元编程性。</p>
<p><strong>Hello World In Ceylon</strong></p>
<pre><code> shared void run() {
    print(&quot;Hello, world!&quot;);
}
</code></pre><p><strong>总结</strong></p>
<p>好啦，以上就是目前主流的可以在JVM上面运行的9种语言。加上Java正好10种。如果你是一个Java开发，那么有必要掌握以上9中的一种，这样可以在一些有特殊需求的场景中有更多的选择。推荐在Groovy、Scala、Kotlin中选一个。</p>
<h4 id="5、值传递与引用传递，JAVA为什么只有值传递"><a href="#5、值传递与引用传递，JAVA为什么只有值传递" class="headerlink" title="5、值传递与引用传递，JAVA为什么只有值传递"></a>5、值传递与引用传递，JAVA为什么只有值传递</h4><p><strong>实参与形参</strong></p>
<p>我们都知道，在Java中定义方法的时候是可以定义参数的。比如Java中的main方法，<code>public static void main(String[] args)</code>，这里面的args就是参数。参数在程序语言中分为形式参数和实际参数。</p>
<blockquote>
<p>形式参数：是在定义函数名和函数体的时候使用的参数,目的是用来接收调用该函数时传入的参数。</p>
<p>实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为“实际参数”。</p>
</blockquote>
<p>简单举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ParamTest pt = new ParamTest();</span><br><span class="line">  pt.sout(&quot;Hollis&quot;);//实际参数为 Hollis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sout(String name) &#123; //形式参数为 name</span><br><span class="line">  System.out.println(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。</p>
<p><strong>值传递与引用传递</strong></p>
<p>上面提到了，当我们调用一个有参函数的时候，会把实际参数传递给形式参数。但是，在程序语言中，这个传递过程中传递的两种情况，即值传递和引用传递。我们来看下程序语言中是如何定义和区分值传递和引用传递的。</p>
<blockquote>
<p>值传递（pass by value）是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p>
<p>引用传递（pass by reference）是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>有了上面的概念，然后大家就可以写代码实践了，来看看Java中到底是值传递还是引用传递 ，于是，最简单的一段代码出来了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ParamTest pt = new ParamTest();</span><br><span class="line"></span><br><span class="line">  int i = 10;</span><br><span class="line">  pt.pass(10);</span><br><span class="line">  System.out.println(&quot;print in main , i is &quot; + i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pass(int j) &#123;</span><br><span class="line">  j = 20;</span><br><span class="line">  System.out.println(&quot;print in pass , j is &quot; + j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，我们在pass方法中修改了参数j的值，然后分别在pass方法和main方法中打印参数的值。输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , j is 20</span><br><span class="line">print in main , i is 10</span><br></pre></td></tr></table></figure>
<p>可见，pass方法内部对name的值的修改并没有改变实际参数i的值。那么，按照上面的定义，有人得到结论：Java的方法传递是值传递。</p>
<p>但是，很快就有人提出质疑了（哈哈，所以，不要轻易下结论咯。）。然后，他们会搬出以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ParamTest pt = new ParamTest();</span><br><span class="line"></span><br><span class="line">  User hollis = new User();</span><br><span class="line">  hollis.setName(&quot;Hollis&quot;);</span><br><span class="line">  hollis.setGender(&quot;Male&quot;);</span><br><span class="line">  pt.pass(hollis);</span><br><span class="line">  System.out.println(&quot;print in main , user is &quot; + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pass(User user) &#123;</span><br><span class="line">  user.setName(&quot;hollischuang&quot;);</span><br><span class="line">  System.out.println(&quot;print in pass , user is &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同样是一个pass方法，同样是在pass方法内修改参数的值。输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=&apos;hollischuang&apos;, gender=&apos;Male&apos;&#125;</span><br><span class="line">print in main , user is User&#123;name=&apos;hollischuang&apos;, gender=&apos;Male&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>经过pass方法执行后，实参的值竟然被改变了，那按照上面的引用传递的定义，实际参数的值被改变了，这不就是引用传递了么。于是，根据上面的两段代码，有人得出一个新的结论：Java的方法中，在传递普通类型的时候是值传递，在传递对象类型的时候是引用传递。</p>
<p>但是，这种表述仍然是错误的。不信你看下面这个参数类型为对象的参数传递：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ParamTest pt = new ParamTest();</span><br><span class="line"></span><br><span class="line">  String name = &quot;Hollis&quot;;</span><br><span class="line">  pt.pass(name);</span><br><span class="line">  System.out.println(&quot;print in main , name is &quot; + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pass(String name) &#123;</span><br><span class="line">  name = &quot;hollischuang&quot;;</span><br><span class="line">  System.out.println(&quot;print in pass , name is &quot; + name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码输出结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , name is hollischuang</span><br><span class="line">print in main , name is Hollis</span><br></pre></td></tr></table></figure></p>
<p>这又作何解释呢？同样传递了一个对象，但是原始参数的值并没有被修改，难道传递对象又变成值传递了？</p>
<p><strong>Java中的值传递</strong></p>
<p>上面，我们举了三个例子，表现的结果却不一样，这也是导致很多初学者，甚至很多高级程序员对于Java的传递类型有困惑的原因。</p>
<p>其实，我想告诉大家的是，上面的概念没有错，只是代码的例子有问题。来，我再来给大家画一下概念中的重点，然后再举几个真正恰当的例子。</p>
<blockquote>
<p>值传递（pass by value）是指在调用函数时将实际参数<code>复制</code>一份传递到函数中，这样在函数中如果对<code>参数</code>进行修改，将不会影响到实际参数。</p>
<p>引用传递（pass by reference）是指在调用函数时将实际参数的地址<code>直接</code>传递到函数中，那么在函数中对<code>参数</code>所进行的修改，将影响到实际参数。</p>
</blockquote>
<p>那么，我来给大家总结一下，值传递和引用传递之前的区别的重点是什么。</p>
<p>[<img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass.jpg" alt="pass" width="474" height="73" class="aligncenter size-full wp-image-2289">][3]</p>
<p>我们上面看过的几个pass的例子中，都只关注了实际参数内容是否有改变。如传递的是User对象，我们试着改变他的name属性的值，然后检查是否有改变。其实，在实验方法上就错了，当然得到的结论也就有问题了。</p>
<p>为什么说实验方法错了呢？这里我们来举一个形象的例子。再来深入理解一下值传递和引用传递，然后你就知道为啥错了。</p>
<p>你有一把钥匙，当你的朋友想要去你家的时候，如果你<code>直接</code>把你的钥匙给他了，这就是引用传递。这种情况下，如果他对这把钥匙做了什么事情，比如他在钥匙上刻下了自己名字，那么这把钥匙还给你的时候，你自己的钥匙上也会多出他刻的名字。</p>
<p>你有一把钥匙，当你的朋友想要去你家的时候，你<code>复刻</code>了一把新钥匙给他，自己的还在自己手里，这就是值传递。这种情况下，他对这把钥匙做什么都不会影响你手里的这把钥匙。</p>
<p>但是，不管上面那种情况，你的朋友拿着你给他的钥匙，进到你的家里，把你家的电视砸了。那你说你会不会受到影响？而我们在pass方法中，改变user对象的name属性的值的时候，不就是在“砸电视”么。</p>
<p>还拿上面的一个例子来举例，我们<code>真正的改变参数</code>，看看会发生什么？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">  ParamTest pt = new ParamTest();</span><br><span class="line"></span><br><span class="line">  User hollis = new User();</span><br><span class="line">  hollis.setName(&quot;Hollis&quot;);</span><br><span class="line">  hollis.setGender(&quot;Male&quot;);</span><br><span class="line">  pt.pass(hollis);</span><br><span class="line">  System.out.println(&quot;print in main , user is &quot; + hollis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pass(User user) &#123;</span><br><span class="line">  user = new User();</span><br><span class="line">  user.setName(&quot;hollischuang&quot;);</span><br><span class="line">  user.setGender(&quot;Male&quot;);</span><br><span class="line">  System.out.println(&quot;print in pass , user is &quot; + user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中，我们在pass方法中，改变了user对象，输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print in pass , user is User&#123;name=&apos;hollischuang&apos;, gender=&apos;Male&apos;&#125;</span><br><span class="line">print in main , user is User&#123;name=&apos;Hollis&apos;, gender=&apos;Male&apos;&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来画一张图，看一下整个过程中发生了什么，然后我再告诉你，为啥Java中只有值传递。</p>
<p>[<img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass1.png" alt="pass1" width="859" height="721" class="aligncenter size-full wp-image-2293">][4]</p>
<p>稍微解释下这张图，当我们在main中创建一个User对象的时候，在堆中开辟一块内存，其中保存了name和gender等数据。然后hollis持有该内存的地址<code>0x123456</code>（图1）。当尝试调用pass方法，并且hollis作为实际参数传递给形式参数user的时候，会把这个地址<code>0x123456</code>交给user，这时，user也指向了这个地址（图2）。然后在pass方法内对参数进行修改的时候，即<code>user = new User();</code>，会重新开辟一块<code>0X456789</code>的内存，赋值给user。后面对user的任何修改都不会改变内存<code>0X123456</code>的内容（图3）。</p>
<p>上面这种传递是什么传递？肯定不是引用传递，如果是引用传递的话，在<code>user=new User()</code>的时候，实际参数的引用也应该改为指向<code>0X456789</code>，但是实际上并没有。</p>
<p>通过概念我们也能知道，这里是把实际参数的引用的地址复制了一份，传递给了形式参数。所以，<strong>上面的参数其实是值传递，把实参对象引用的地址当做值传递给了形式参数。</strong></p>
<p>我们再来回顾下之前的那个“砸电视”的例子，看那个例子中的传递过程发生了什么。</p>
<p>[<img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass21.png" alt="pass2" width="832" height="732" class="aligncenter size-full wp-image-2307">][5]</p>
<p>同样的，在参数传递的过程中，实际参数的地址<code>0X1213456</code>被拷贝给了形参，只是，在这个方法中，并没有对形参本身进行修改，而是修改的形参持有的地址中存储的内容。</p>
<p>所以，值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。在判断实参内容有没有受影响的时候，要看传的的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。就像钥匙和房子的关系。</p>
<p>那么，既然这样，为啥上面同样是传递对象，传递的String对象和User对象的表现结果不一样呢？我们在pass方法中使用<code>name = &quot;hollischuang&quot;;</code>试着去更改name的值，阴差阳错的直接改变了name的引用的地址。因为这段代码，会new一个String，在把引用交给name，即等价于<code>name = new String(&quot;hollischuang&quot;);</code>。而原来的那个”Hollis”字符串还是由实参持有着的，所以，并没有修改到实际参数的值。</p>
<p>[<img src="http://www.hollischuang.com/wp-content/uploads/2018/04/pass3.png" alt="pass3" width="515" height="399" class="aligncenter size-full wp-image-2311">][6]</p>
<p><strong>所以说，Java中其实还是值传递的，只不过对于对象参数，值的内容是对象的引用。</strong></p>
<p><strong>总结</strong></p>
<p>无论是值传递还是引用传递，其实都是一种求值策略([Evaluation strategy][7])。在求值策略中，还有一种叫做按共享传递(call by sharing)。其实Java中的参数传递严格意义上说应该是按共享传递。</p>
<blockquote>
<p>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值）。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。</p>
</blockquote>
<p>简单点说，Java中的传递，是值传递，而这个值，实际上是对象的引用。</p>
<p>而按共享传递其实只是按值传递的一个特例罢了。所以我们可以说Java的传递是按共享传递，或者说Java中的传递是值传递。</p>
<h4 id="6、封装、继承、多态"><a href="#6、封装、继承、多态" class="headerlink" title="6、封装、继承、多态"></a>6、封装、继承、多态</h4><h5 id="6-1多态、方法重写与重载"><a href="#6-1多态、方法重写与重载" class="headerlink" title="6.1多态、方法重写与重载"></a>6.1多态、方法重写与重载</h5><p>多态的概念呢比较简单，就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。</p>
<p>如果按照这个概念来定义的话，那么多态应该是一种运行期的状态。<br>为了实现运行期的多态，或者说是动态绑定，需要满足三个条件。</p>
<p>即有类继承或者接口实现、子类要重写父类的方法、父类的引用指向子类的对象。</p>
<p>简单来一段代码解释下：</p>
<pre><code>public class Parent{

    public void call(){
        sout(&quot;im Parent&quot;);
    }
}

public class Son extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout(&quot;im Son&quot;);
    }
}

public class Daughter extends Parent{// 1.有类继承或者接口实现
    public void call(){// 2.子类要重写父类的方法
        sout(&quot;im Daughter&quot;);
    }
}

public class Test{

    public static void main(String[] args){
        Parent p = new Son(); //3.父类的引用指向子类的对象
        Parent p1 = new Daughter(); //3.父类的引用指向子类的对象
    }
}
</code></pre><p>这样，就实现了多态，同样是Parent类的实例，p.call 调用的是Son类的实现、p1.call调用的是Daughter的实现。<br>有人说，你自己定义的时候不就已经知道p是son，p1是Daughter了么。但是，有些时候你用到的对象并不都是自己声明的啊 。<br>比如Spring 中的IOC出来的对象，你在使用的时候就不知道他是谁，或者说你可以不用关心他是谁。根据具体情况而定。</p>
<p>另外，还有一种说法，包括维基百科也说明，多态还分为动态多态和静态多态。<br>上面提到的那种动态绑定认为是动态多态，因为只有在运行期才能知道真正调用的是哪个类的方法。</p>
<p>还有一种静态多态，一般认为Java中的函数重载是一种静态多态，因为他需要在编译期决定具体调用哪个方法、</p>
<p>关于这个动态静态的说法，我更偏向于重载和多态其实是无关的。</p>
<p>但是也要看情况，普通场合，我会认为只有方法的重写算是多态，毕竟这是我的观点。但是如果在面试的时候，我“可能”会认为重载也算是多态，毕竟面试官也有他的观点。我会和面试官说：我认为，多态应该是一种运行期特性，Java中的重写是多态的体现。不过也有人提出重载是一种静态多态的想法，这个问题在StackOverflow等网站上有很多人讨论，但是并没有什么定论。我更加倾向于重载不是多态。</p>
<p>这样沟通，既能体现出你了解的多，又能表现出你有自己的思维，不是那种别人说什么就是什么的。</p>
<p><img src="https://camo.githubusercontent.com/56f37bde332b37d4b15324884070e97f9155b9d7/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f6f7665726c6f6164696e672d76732d6f766572726964696e672e706e67" alt="img"></p>
<p>重载（Overloading）和重写（Overriding）是Java中两个比较重要的概念。但是对于新手来说也比较容易混淆。本文通过两个简单的例子说明了他们之间的区别。</p>
<p><strong>重载</strong></p>
<p>简单说，就是函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p><strong>重写</strong></p>
<p>重写指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<p><strong>重载 VS 重写</strong></p>
<p>关于重载和重写，你应该知道以下几点：</p>
<blockquote>
<p>1、重载是一个编译期概念、重写是一个运行期间概念。</p>
<p>2、重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法。</p>
<p>3、重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</p>
<p>4、因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关。（注：严格来说，重载是编译时多态，即静态多态。但是，Java中提到的多态，在不特别说明的情况下都指动态多态）</p>
</blockquote>
<p><strong>重写的例子</strong></p>
<p>下面是一个重写的例子，看完代码之后不妨猜测一下输出结果：</p>
<pre><code>class Dog{
    public void bark(){
        System.out.println(&quot;woof &quot;);
    }
}
class Hound extends Dog{
    public void sniff(){
        System.out.println(&quot;sniff &quot;);
    }

    public void bark(){
        System.out.println(&quot;bowl&quot;);
    }
}

public class OverridingTest{
    public static void main(String [] args){
        Dog dog = new Hound();
        dog.bark();
    }
}
</code></pre><p>输出结果：</p>
<pre><code>bowl
</code></pre><p>上面的例子中，<code>dog</code>对象被定义为<code>Dog</code>类型。在编译期，编译器会检查Dog类中是否有可访问的<code>bark()</code>方法，只要其中包含<code>bark（）</code>方法，那么就可以编译通过。在运行期，<code>Hound</code>对象被<code>new</code>出来，并赋值给<code>dog</code>变量，这时，JVM是明确的知道<code>dog</code>变量指向的其实是<code>Hound</code>对象的引用。所以，当<code>dog</code>调用<code>bark()</code>方法的时候，就会调用<code>Hound</code>类中定义的<code>bark（）</code>方法。这就是所谓的动态多态性。</p>
<p><strong>重写的条件</strong></p>
<blockquote>
<p>参数列表必须完全与被重写方法的相同；</p>
<p>返回类型必须完全与被重写方法的返回类型相同；</p>
<p>访问级别的限制性一定不能比被重写方法的强；</p>
<p>访问级别的限制性可以比被重写方法的弱；</p>
<p>重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常</p>
<p>重写的方法能够抛出更少或更有限的异常（也就是说，被重写的方法声明了异常，但重写的方法可以什么也不声明）</p>
<p>不能重写被标示为final的方法；</p>
<p>如果不能继承一个方法，则不能重写这个方法。</p>
</blockquote>
<p><strong>重载的例子</strong></p>
<pre><code>class Dog{
    public void bark(){
        System.out.println(&quot;woof &quot;);
    }

    //overloading method
    public void bark(int num){
        for(int i=0; i&lt;num; i++)
            System.out.println(&quot;woof &quot;);
    }
}
</code></pre><p>上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个int类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。</p>
<p><strong>重载的条件</strong></p>
<blockquote>
<p>被重载的方法必须改变参数列表；</p>
<p>被重载的方法可以改变返回类型；</p>
<p>被重载的方法可以改变访问修饰符；</p>
<p>被重载的方法可以声明新的或更广的检查异常；</p>
<p>方法能够在同一个类中或者在一个子类中被重载。</p>
</blockquote>
<h5 id="6-2-JAVA的继承与实现"><a href="#6-2-JAVA的继承与实现" class="headerlink" title="6.2 JAVA的继承与实现"></a>6.2 JAVA的继承与实现</h5><p><strong>继承的概念</strong></p>
<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>
<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>
<p><strong>生活中的继承：</strong></p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/14B0951E-FC75-47A3-B611-4E1883887339.jpg" alt="img"></p>
<p>兔子和羊属于食草动物类，狮子和豹属于食肉动物类。</p>
<p>食草动物和食肉动物又是属于动物类。</p>
<p>所以继承需要符合的关系是：is-a，父类更通用，子类更具体。</p>
<p>虽然食草动物和食肉动物都是属于动物，但是两者的属性和行为上有差别，所以子类会具有父类的一般特性也会具有自身的特性。</p>
<p><strong>类的继承格式</strong></p>
<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class 父类 &#123;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class 子类 extends 父类 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>为什么需要继承</strong></p>
<p>接下来我们通过实例来说明这个需求。</p>
<p>开发动物类，其中动物分别为企鹅以及老鼠，要求如下：</p>
<ul>
<li><p>企鹅：属性（姓名，id），方法（吃，睡，自我介绍）</p>
</li>
<li><p>老鼠：属性（姓名，id），方法（吃，睡，自我介绍）</p>
<p>​                                                                                        企鹅类</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Penguin &#123; </span><br><span class="line">    private String name; </span><br><span class="line">    private int id; </span><br><span class="line">    public Penguin(String myName, int  myid) &#123; </span><br><span class="line">        name = myName; </span><br><span class="line">        id = myid; </span><br><span class="line">    &#125; </span><br><span class="line">    public void eat()&#123; </span><br><span class="line">        System.out.println(name+&quot;正在吃&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep()&#123;</span><br><span class="line">        System.out.println(name+&quot;正在睡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void introduction() &#123; </span><br><span class="line">        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​                                                                                            老鼠类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Mouse &#123; </span><br><span class="line">    private String name; </span><br><span class="line">    private int id; </span><br><span class="line">    public Mouse(String myName, int  myid) &#123; </span><br><span class="line">        name = myName; </span><br><span class="line">        id = myid; </span><br><span class="line">    &#125; </span><br><span class="line">    public void eat()&#123; </span><br><span class="line">        System.out.println(name+&quot;正在吃&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep()&#123;</span><br><span class="line">        System.out.println(name+&quot;正在睡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void introduction() &#123; </span><br><span class="line">        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123; </span><br><span class="line">    private String name;  </span><br><span class="line">    private int id; </span><br><span class="line">    public Animal(String myName, int myid) &#123; </span><br><span class="line">        name = myName; </span><br><span class="line">        id = myid;</span><br><span class="line">    &#125; </span><br><span class="line">    public void eat()&#123; </span><br><span class="line">        System.out.println(name+&quot;正在吃&quot;); </span><br><span class="line">    &#125;</span><br><span class="line">    public void sleep()&#123;</span><br><span class="line">        System.out.println(name+&quot;正在睡&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void introduction() &#123; </span><br><span class="line">        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Penguin extends Animal &#123; </span><br><span class="line">    public Penguin(String myName, int myid) &#123; </span><br><span class="line">        super(myName, myid); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Mouse extends Animal &#123; </span><br><span class="line">    public Mouse(String myName, int myid) &#123; </span><br><span class="line">        super(myName, myid); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>继承类型</strong></p>
<p>需要注意的是 Java 不支持多继承，但支持多重继承。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2013/12/types_of_inheritance-1.png" alt="img"></p>
<p><strong>继承的特性</strong></p>
<ul>
<li>子类拥有父类非 private 的属性、方法。</li>
<li>子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
<li>Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 A 类继承 B 类，B 类继承 C 类，所以按照关系就是 C 类是 B 类的父类，B 类是 A 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。</li>
<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>
</ul>
<hr>
<p><strong>继承关键字</strong></p>
<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承object（这个类在 <strong>java.lang</strong> 包中，所以不需要 <strong>import</strong>）祖先类。</p>
<p><strong>extends关键字</strong></p>
<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123; </span><br><span class="line">    private String name;   </span><br><span class="line">    private int id; </span><br><span class="line">    public Animal(String myName, String myid) &#123; </span><br><span class="line">        //初始化属性值</span><br><span class="line">    &#125; </span><br><span class="line">    public void eat() &#123;  //吃东西方法的具体实现  &#125; </span><br><span class="line">    public void sleep() &#123; //睡觉方法的具体实现  &#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">public class Penguin  extends  Animal&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>implements关键字</strong></p>
<p>使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public interface A &#123;</span><br><span class="line">    public void eat();</span><br><span class="line">    public void sleep();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public interface B &#123;</span><br><span class="line">    public void show();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class C implements A,B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>super 与 this 关键字</strong></p>
<p>super关键字：我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>
<p>this关键字：指向自己的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">class Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;animal : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">  void eat() &#123;</span><br><span class="line">    System.out.println(&quot;dog : eat&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  void eatTest() &#123;</span><br><span class="line">    this.eat();   // this 调用自己的方法</span><br><span class="line">    super.eat();  // super 调用父类方法</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public class Test &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Animal a = new Animal();</span><br><span class="line">    a.eat();</span><br><span class="line">    Dog d = new Dog();</span><br><span class="line">    d.eatTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">animal : eat</span><br><span class="line">dog : eat</span><br><span class="line">animal : eat</span><br></pre></td></tr></table></figure>
<p><strong>final关键字</strong></p>
<p>final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>
<ul>
<li><p>声明类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">final class 类名 &#123;//类体&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>声明方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修饰符(public/private/default/protected) final 返回值类型 方法名()&#123;//方法体&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>注</strong>:实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为 final，但是实例变量并不是 final</p>
<p><strong>构造器</strong></p>
<p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 <strong>super</strong> 关键字调用父类的构造器并配以适当的参数列表。</p>
<p>如果父类构造器没有参数，则在子类的构造器中不需要使用 <strong>super</strong> 关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class SuperClass &#123;</span><br><span class="line">  private int n;</span><br><span class="line">  SuperClass()&#123;</span><br><span class="line">    System.out.println(&quot;SuperClass()&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  SuperClass(int n) &#123;</span><br><span class="line">    System.out.println(&quot;SuperClass(int n)&quot;);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SubClass 类继承</span><br><span class="line">class SubClass extends SuperClass&#123;</span><br><span class="line">  private int n;</span><br><span class="line">  </span><br><span class="line">  SubClass()&#123; // 自动调用父类的无参数构造器</span><br><span class="line">    System.out.println(&quot;SubClass&quot;);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public SubClass(int n)&#123; </span><br><span class="line">    super(300);  // 调用父类中带有参数的构造器</span><br><span class="line">    System.out.println(&quot;SubClass(int n):&quot;+n);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// SubClass2 类继承</span><br><span class="line">class SubClass2 extends SuperClass&#123;</span><br><span class="line">  private int n;</span><br><span class="line">  </span><br><span class="line">  SubClass2()&#123;</span><br><span class="line">    super(300);  // 调用父类中带有参数的构造器</span><br><span class="line">    System.out.println(&quot;SubClass2&quot;);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  public SubClass2(int n)&#123; // 自动调用父类的无参数构造器</span><br><span class="line">    System.out.println(&quot;SubClass2(int n):&quot;+n);</span><br><span class="line">    this.n = n;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TestSuperSub&#123;</span><br><span class="line">  public static void main (String args[])&#123;</span><br><span class="line">    System.out.println(&quot;------SubClass 类继承------&quot;);</span><br><span class="line">    SubClass sc1 = new SubClass();</span><br><span class="line">    SubClass sc2 = new SubClass(100); </span><br><span class="line">    System.out.println(&quot;------SubClass2 类继承------&quot;);</span><br><span class="line">    SubClass2 sc3 = new SubClass2();</span><br><span class="line">    SubClass2 sc4 = new SubClass2(200); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">------SubClass 类继承------</span><br><span class="line">SuperClass()</span><br><span class="line">SubClass</span><br><span class="line">SuperClass(int n)</span><br><span class="line">SubClass(int n):100</span><br><span class="line">------SubClass2 类继承------</span><br><span class="line">SuperClass(int n)</span><br><span class="line">SubClass2</span><br><span class="line">SuperClass()</span><br><span class="line">SubClass2(int n):200</span><br></pre></td></tr></table></figure>
<p>Java是一个面向对象的语言。每一个学习过Java的人都知道，封装、继承、多态是面向对象的三个特征。每个人在刚刚学习继承的时候都会或多或少的有这样一个印象：继承可以帮助我实现类的复用。所以，很多开发人员在需要复用一些代码的时候会很自然的使用类的继承的方式，因为书上就是这么写的（老师就是这么教的）。但是，其实这样做是不对的。长期大量的使用继承会给代码带来很高的维护成本。</p>
<p>本文将介绍组合和继承的概念及区别，并从多方面分析在写代码时如何进行选择。</p>
<p><strong>面向对象的复用技术</strong></p>
<p>前面提到复用，这里就简单介绍一下面向对象的复用技术。</p>
<p>复用性是面向对象技术带来的很棒的潜在好处之一。如果运用的好的话可以帮助我们节省很多开发时间，提升开发效率。但是，如果被滥用那么就可能产生很多难以维护的代码。</p>
<p>作为一门面向对象开发的语言，代码复用是Java引人注意的功能之一。Java代码的复用有继承，组合以及代理三种具体的表现形式。本文将重点介绍继承复用和组合复用。</p>
<p><strong>继承</strong></p>
<p>继承（Inheritance）是一种联结类与类的层次模型。指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力，继承是类与类或者接口与接口之间最常见的关系；继承是一种<a href="https://zh.wikipedia.org/wiki/Is-a" target="_blank" rel="noopener"><code>is-a</code></a>关系。（图片来自网络，侵删。）</p>
<p><a href="https://camo.githubusercontent.com/55f7ec5b03215413098828f82acc313cd34a0b69/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f47656e6572616c697a6174696f6e2e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/55f7ec5b03215413098828f82acc313cd34a0b69/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f47656e6572616c697a6174696f6e2e6a7067" alt="Inheritance"></a></p>
<h5 id="6-3-组合"><a href="#6-3-组合" class="headerlink" title="6.3 组合"></a>6.3 组合</h5><p>组合(Composition)体现的是整体与部分、拥有的关系，即<a href="https://en.wikipedia.org/wiki/Has-a" target="_blank" rel="noopener"><code>has-a</code></a>的关系。</p>
<p><a href="https://camo.githubusercontent.com/6ed93acd5db6ec062395c57511a5a4f221c9643c/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f436f6d706f736974696f6e2e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6ed93acd5db6ec062395c57511a5a4f221c9643c/687474703a2f2f7777772e686f6c6c6973636875616e672e636f6d2f77702d636f6e74656e742f75706c6f6164732f323031362f30332f436f6d706f736974696f6e2e6a7067" alt="Composition"></a></p>
<p><strong>组合与继承的区别和联系</strong></p>
<blockquote>
<p>在<code>继承</code>结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种<code>白盒式代码复用</code>。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）</p>
<p><code>组合</code>是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是<code>黑盒式代码复用</code>。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）</p>
<p><code>继承</code>，在写代码的时候就要指名具体继承哪个类，所以，在<code>编译期</code>就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）</p>
<p><code>组合</code>，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在<code>运行期</code>确定。</p>
</blockquote>
<p><strong>优缺点对比</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>组 合 关 系</th>
<th>继 承 关 系</th>
</tr>
</thead>
<tbody>
<tr>
<td>优点：不破坏封装，整体类与局部类之间松耦合，彼此相对独立</td>
<td>缺点：破坏封装，子类与父类之间紧密耦合，子类依赖于父类的实现，子类缺乏独立性</td>
</tr>
<tr>
<td>优点：具有较好的可扩展性</td>
<td>缺点：支持扩展，但是往往以增加系统结构的复杂度为代价</td>
</tr>
<tr>
<td>优点：支持动态组合。在运行时，整体对象可以选择不同类型的局部对象</td>
<td>缺点：不支持动态继承。在运行时，子类无法选择不同的父类</td>
</tr>
<tr>
<td>优点：整体类可以对局部类进行包装，封装局部类的接口，提供新的接口</td>
<td>缺点：子类不能改变父类的接口</td>
</tr>
<tr>
<td>缺点：整体类不能自动获得和局部类同样的接口</td>
<td>优点：子类能自动继承父类的接口</td>
</tr>
<tr>
<td>缺点：创建整体类的对象时，需要创建所有局部类的对象</td>
<td>优点：创建子类的对象时，无须创建父类的对象</td>
</tr>
</tbody>
</table>
</div>
<p><strong>如何选择</strong></p>
<p>相信很多人都知道面向对象中有一个比较重要的原则『多用组合、少用继承』或者说『组合优于继承』。从前面的介绍已经优缺点对比中也可以看出，组合确实比继承更加灵活，也更有助于代码维护。</p>
<p>所以，</p>
<blockquote>
<p><strong>建议在同样可行的情况下，优先使用组合而不是继承。</strong></p>
<p><strong>因为组合更安全，更简单，更灵活，更高效。</strong></p>
</blockquote>
<p>注意，并不是说继承就一点用都没有了，前面说的是【在同样可行的情况下】。有一些场景还是需要使用继承的，或者是更适合使用继承。</p>
<blockquote>
<p>继承要慎用，其使用场合仅限于你确信使用该技术有效的情况。一个判断方法是，问一问自己是否需要从新类向基类进行向上转型。如果是必须的，则继承是必要的。反之则应该好好考虑是否需要继承。《<a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DHzJzud6zOdocQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67vo5P8BMUBgoEC56fBbgyn5pS4hLH%2FP02ckKYNRBWOBBey11vvWwHXSniyi5vWXIZhtlrJbLMDAQihpQCXu2JnPFYKQlNeOGCsYMXU3NNCg%2F&amp;pvid=10_125.119.86.125_222_1458652212179" target="_blank" rel="noopener">Java编程思想</a>》</p>
<p>只有当子类真正是超类的子类型时，才适合用继承。换句话说，对于两个类A和B，只有当两者之间确实存在<a href="https://zh.wikipedia.org/wiki/Is-a" target="_blank" rel="noopener"><code>is-a</code></a>关系的时候，类B才应该继承类A。《<a href="http://s.click.taobao.com/t?e=m%3D2%26s%3DwIPn8%2BNPqLwcQipKwQzePOeEDrYVVa64K7Vc7tFgwiHjf2vlNIV67vo5P8BMUBgoUOZr0mLjusdpS4hLH%2FP02ckKYNRBWOBBey11vvWwHXSniyi5vWXIZvgXwmdyquYbNLnO%2BjzYQLqKnzbV%2FMLqnMYMXU3NNCg%2F&amp;pvid=10_125.119.86.125_345_1458652241780" target="_blank" rel="noopener">Effective Java</a>》</p>
</blockquote>
<h4 id="7、构造函数与默认构造函数"><a href="#7、构造函数与默认构造函数" class="headerlink" title="7、构造函数与默认构造函数"></a>7、构造函数与默认构造函数</h4><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。 特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p>
<p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。构造器的函数名称必须和它所属的类的名称相同。 它承担着初始化对象数据成员的任务。</p>
<p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如int -&gt; 0，Integet -&gt; null。</p>
<h4 id="8、类变量、成员变量和局部变量和作用域"><a href="#8、类变量、成员变量和局部变量和作用域" class="headerlink" title="8、类变量、成员变量和局部变量和作用域"></a>8、类变量、成员变量和局部变量和作用域</h4><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @author Hollis</span><br><span class="line"> */</span><br><span class="line">public class Variables &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类变量</span><br><span class="line">     */</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 成员变量</span><br><span class="line">     */</span><br><span class="line">    private int b;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 局部变量</span><br><span class="line">     * @param c</span><br><span class="line">     */</span><br><span class="line">    public void test(int c)&#123;</span><br><span class="line">        int d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面定义的三个变量中，变量a就是类变量，变量b就是成员变量，而变量c和d是局部变量。</p>
<ul>
<li>public :表明该成员变量或者方法是对所有类或者对象都是可见的,所有类或者对象都可以直接访问</li>
<li>private:表明该成员变量或者方法是私有的,只有当前类对其具有访问权限,除此之外其他类或者对象都没有访问权限.子类也没有访问权限.</li>
<li>protected:表明成员变量或者方法对类自身,与同在一个包中的其他类可见,其他包下的类不可访问,除非是他的子类</li>
<li>default:表明该成员变量或者方法只有自己和其位于同一个包的内可见,其他包内的类不能访问,即便是它的子类</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/14/编程技巧/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/14/编程技巧/" itemprop="url">编程技巧</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-14T13:16:33+08:00">
                2019-10-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>字母大小写转换的快捷方法：</p>
<ul>
<li>统一转成大写：ch &amp; 0b11011111 简写：ch &amp; 0xDF</li>
<li>统一转成小写：ch | 0b00100000 简写：ch | 0x20</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/07/C-中的auto和for循环/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/07/C-中的auto和for循环/" itemprop="url">C++中的auto和for循环</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-07T08:22:50+08:00">
                2019-10-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h5 id="1、auto的使用"><a href="#1、auto的使用" class="headerlink" title="1、auto的使用"></a>1、auto的使用</h5><p>c++11引入了auto类型说明符，auto让编译器通过初始值来推算变量的类型，所以auto定义的变量必须有初始值。<br>使用auto也能在一条语句中声明多个变量，因为一条声明语句只能有一个基本数据类型，所以该语句中所有变量的初始基本数据类型都必须一样：<br>eg: auto i=0,*p=&amp; i; //正确 auto sz=0,pi=3.14;//错误，sz和pi的类型不一样。</p>
<h5 id="2、范围for循环"><a href="#2、范围for循环" class="headerlink" title="2、范围for循环"></a>2、范围for循环</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration:expression)</span><br><span class="line">	statement</span><br></pre></td></tr></table></figure>
<blockquote>
<p>expression 部分是一个对象，用于表示一个序列，declaration部分负责定义一个变量，该变量被用于访问序列中的基础元素，每次迭代declaration部分的变量会被初始化为expression部分的下一个元素值。</p>
</blockquote>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello,World!"</span>)</span></span>;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'o'</span>)</span><br><span class="line">			cnt++;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> c : s)          <span class="comment">//拷贝s中的元素</span></span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'o'</span>)</span><br><span class="line">			c=<span class="string">'a'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)         <span class="comment">//修改s中的元素</span></span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'o'</span>)</span><br><span class="line">			c = <span class="string">'a'</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;c : s)   <span class="comment">//只读s中的元素</span></span><br><span class="line">		<span class="keyword">if</span> (c == <span class="string">'a'</span>)</span><br><span class="line">			cnt++;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行</p>
<blockquote>
<p>2</p>
<p>Hello,World!</p>
<p>Hello,World!</p>
<p>Hella,Warld!</p>
<p>4</p>
<p>Hella,Warld!</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/10/04/C-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/04/C-STL/" itemprop="url">C++STL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-04T09:14:13+08:00">
                2019-10-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>,<span class="number">-1</span>);<span class="comment">// 直接初始化 10个元素 全为 -1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2 = ivec;<span class="comment">//拷贝初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3&#123;<span class="number">10</span>&#125;;<span class="comment">//一个元素 10 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3&#123;<span class="number">10</span>，<span class="number">1</span>&#125;;<span class="comment">//两个元素 10  和 1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec&#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>&#125;;<span class="comment">//列表初始化 直接方式</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2 = &#123;<span class="string">"a"</span>,<span class="string">"an"</span>,<span class="string">"the"</span>&#125;;<span class="comment">//列表初始化 拷贝方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始化 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec(<span class="number">10</span>);    <span class="comment">// 10个元素，每个值都是0 </span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec(<span class="number">10</span>); <span class="comment">// 10个元素，每个值都是空 string 对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec2&#123;<span class="number">10</span>&#125;;<span class="comment">// 10个元素，每个值都是空 string 对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec3&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;<span class="comment">// 10个 "hi"元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec3(<span class="number">10</span>, <span class="string">"hi"</span>);<span class="comment">// 10个 "hi"元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 .push_back() 添加元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec2; <span class="comment">//空vec对象</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">ivec2.push_back(i);<span class="comment">// 一次把整数值 放到 ivec2尾部 结束后 ivec2有100个元素 0~99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实时添加 string 元素</span></span><br><span class="line"><span class="built_in">string</span> word;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;<span class="comment">//空对象</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word) </span><br><span class="line">text.push_back(word);<span class="comment">// 把word添加到 text 后面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用范围for  + 引用 访问 并改变vector元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">// 列表直接初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)<span class="comment">// 对于v中每个 元素的 引用 需要改变其值</span></span><br><span class="line">i *= i;      <span class="comment">// 变成原来值 的 平方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v) <span class="comment">// 仅读取其中的变量</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector 对象大小 类型为size_type</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type se = iv.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引[] 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数</span></span><br><span class="line"><span class="comment">// 索引不能添加元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; scores(<span class="number">11</span>,<span class="number">0</span>);<span class="comment">//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade)&#123;</span><br><span class="line"><span class="keyword">if</span>(grade &lt;= <span class="number">100</span>) ++scores[grade/<span class="number">10</span>];</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// cin 读入一组词 改成大写 存入 vector中  #include &lt;cctype&gt; 使用toupper()</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sv;</span><br><span class="line"><span class="built_in">string</span> word1 = <span class="string">"qwe"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; word1)&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : word1) c = <span class="built_in">toupper</span>(c);</span><br><span class="line">	sv.push_back(word1); 	</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; word1 &lt;&lt; <span class="built_in">endl</span>; <span class="built_in">vector</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改 字符串 第一个元素为大小字符</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())&#123;<span class="comment">//确保 s非空</span></span><br><span class="line">  <span class="keyword">auto</span> it = s.begin();<span class="comment">// it 指向 s的第一个字符 类似指针 的作用</span></span><br><span class="line">  *it = <span class="built_in">toupper</span>(*it);<span class="comment">// 将当前字符改写成大写形式  *it 解引用迭代器 得到其所指向的 对象  是其指向对象的别名 引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串的第一个单词 改写成大写</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">	*it = <span class="built_in">toupper</span>(*it);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代器类型  iterator (具有读写功能)  const_iterator 具有 读功能  不具有写功能</span></span><br><span class="line"><span class="comment">// 对象为常量 只具有常量类型的迭代器 const_iterator  对象为变量具有 iterator 和 const_iterator</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;<span class="comment">// 迭代器 it 可以读写 vector&lt;int&gt; 类型容器 的元素</span></span><br><span class="line"> <span class="built_in">string</span>::iterator it2;   <span class="comment">// it2 可以读写  string对象 中的字符</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;<span class="comment">//it3只能读元素，不能写元素</span></span><br><span class="line"> <span class="built_in">string</span>::const_iterator it4;     <span class="comment">//it4只能读字符，不能写字符</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// cbegin()   cend() 返回 常量 迭代器 仅能读取 容器元素 不能修改</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv;        <span class="comment">// 变量</span></span><br><span class="line"> <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; civ; <span class="comment">// 常量</span></span><br><span class="line"> <span class="keyword">auto</span> it1 = iv.begin(); <span class="comment">//  it1的类型为 vector&lt;int&gt;::iterator  能读写iv的元素</span></span><br><span class="line"> <span class="keyword">auto</span> it2 = iv.cbegin(); <span class="comment">// it2的类型为 vector&lt;int&gt;::const_iterator  能读iv的元素 不能修改 iv的元素</span></span><br><span class="line"> <span class="keyword">auto</span> it3 = civ.begin(); <span class="comment">// it3的类型为 vector&lt;int&gt;::const_iterator  能读civ的元素 不能修改 civ的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 访问 容器元素对象的 成员函数   (*it).empty  等同于 it-&gt;empty()  解引用 和成员访问</span></span><br><span class="line">  <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; text;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = text.cbegin(); it !=text.cend() &amp;&amp; !it-&gt;empty(); ++it)</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 迭代器 运算</span></span><br><span class="line">  <span class="keyword">auto</span> mid = iv.begin() + iv.size()/<span class="number">2</span>; <span class="comment">//指向容器的中间位置</span></span><br><span class="line">  <span class="keyword">if</span> (it &lt; mid) <span class="comment">// 处理前半部分元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个迭代器相减 得到的类型为 带符号整数  difference_type</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规二分查找算法</span></span><br><span class="line"><span class="comment">// 升序数组 查找的元素  范围开始  结束 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> key, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high)<span class="comment">//  缩小范围 </span></span><br><span class="line">    &#123;</span><br><span class="line">	mid = (low + high) / <span class="number">2</span>;<span class="comment">//更新中间元素的 下标 </span></span><br><span class="line">	<span class="keyword">if</span> (key == <span class="built_in">array</span>[mid])<span class="comment">//中间元素是否 等于所查找的元素 </span></span><br><span class="line">	    <span class="keyword">return</span> mid+<span class="number">1</span>;<span class="comment">//相等 返回元素下标  </span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (key &lt; <span class="built_in">array</span>[mid])<span class="comment">//所查元素 比 中间元素小  则在 前区间查找 </span></span><br><span class="line">	    high = mid - <span class="number">1</span>;<span class="comment">//将区间 右侧 退后 到 中间元素下标前一个元素  搜索 范围为  low，mid-1</span></span><br><span class="line">	<span class="keyword">else</span><span class="comment">//所查元素 比 中间元素大 则 在后区间查找 </span></span><br><span class="line">	    low = mid + <span class="number">1</span>;<span class="comment">//将区间  左测 提至  中间元素下标后一个元素    搜索 范围 mid+1，high</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器完成二分查找</span></span><br><span class="line"> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; text<span class="comment">// 升序容器</span></span><br><span class="line"> <span class="keyword">auto</span> b = text.begin(), e = text.end();<span class="comment">//起始 结束位置</span></span><br><span class="line"> <span class="keyword">auto</span> mid = b + (e - b)/<span class="number">2</span>;<span class="comment">//中间位置</span></span><br><span class="line"> <span class="keyword">while</span>(low &lt;= end &amp;&amp; *mid != key)&#123;</span><br><span class="line">	<span class="keyword">if</span>(key &lt; *mid) e = mid - <span class="number">1</span>;<span class="comment">//所查元素 比 中间元素小  则在 前区间查找</span></span><br><span class="line">	<span class="keyword">else</span> b = mid + <span class="number">1</span>;<span class="comment">// 所查元素 比 中间元素大 则 在后区间查找</span></span><br><span class="line">	mid =  b + (e - b)/<span class="number">2</span>;<span class="comment">//更新 中间位置</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用索引[] 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数</span></span><br><span class="line"><span class="comment">// 索引不能添加元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; scores(<span class="number">11</span>,<span class="number">0</span>);<span class="comment">//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade)&#123;</span><br><span class="line"><span class="keyword">if</span>(grade &lt;= <span class="number">100</span>) ++scores[grade/<span class="number">10</span>];</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 使用迭代器 访问 计算vector对象元素索引   统计各个分数段上 出现的 成绩个数</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; scores(<span class="number">11</span>,<span class="number">0</span>);<span class="comment">//11个分数段， 0~9，10~19，...,90~99，100 计数值全部初始化为0</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">auto</span> it0 = scores.begin();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade)&#123;</span><br><span class="line">	<span class="keyword">auto</span> it = it0 +  grade/<span class="number">10</span>;</span><br><span class="line">	<span class="keyword">if</span>(grade &lt;= <span class="number">100</span>) ++*it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/09/26/离散数学/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/26/离散数学/" itemprop="url">离散数学</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-09-26T14:55:42+08:00">
                2019-09-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="第1章-数学语言与证明方法"><a href="#第1章-数学语言与证明方法" class="headerlink" title="第1章 数学语言与证明方法"></a>第1章 数学语言与证明方法</h3><h5 id="1、逻辑符号"><a href="#1、逻辑符号" class="headerlink" title="1、逻辑符号"></a>1、逻辑符号</h5><p>$\neg p$：非$p$ 。（否定联结词）</p>
<p>$p\wedge q$：$p$并且$q$。（合取联结词）</p>
<p>$p\vee q$：$p$或$q$。（析取联结词）</p>
<p>$p\to q$：如果$p$，则$q$。（蕴含联结词）</p>
<p>$p\leftrightarrow q$：$p$当且仅当$q$。（等价联结词）</p>
<h5 id="2、集合"><a href="#2、集合" class="headerlink" title="2、集合"></a>2、集合</h5><p>1)集合的定义：满足某条性质的个体的组合</p>
<p>2)集合的特点：</p>
<p>a:集合中的元素各不相同                                       $\{1,2,3,4\}=\{1,1,2,3,4\}$</p>
<p>b:集合中的元素不规定次序                                   $\{a,b,c\}=\{b,c,a\}$   </p>
<p>c:同一个集合可以有多种不同的表示方法          $A_1=\{x|x是偶素数\}=\{2\}$</p>
<p>3)集合之间的关系：</p>
<p>①$A\subseteq B$：A包含于B</p>
<p>②$A=B$：A等于B</p>
<p>③$A\subseteq B$ 且 $A\neq B$：A为B的真子集</p>
<p>4）集合的运算</p>
<p>(1)$A\cup B$：A与B的并集</p>
<p>(2)$A\cap B$：A与B的交集</p>
<p>(3)$A-B$：B对A的相对补集（属于A而不属于B）</p>
<p>(4)$A\oplus B$：A与B的对称差集（属于A而不属于B，或属于B而不属于A的元素组成的集合）</p>
<p>(5)$E-A$或$\thicksim A$：A的绝对补集（E为全集）</p>
<p><img src="/2019/09/26/离散数学/Users\dufub\Desktop\Leselier\source\_posts\离散数学\1.jpg" alt></p>
<p>(6)多个集合上—并</p>
<p>$\bigcup\limits_{i=1}^{n}=A_1\cup A_2…\cup A_n$</p>
<p>(7)多个集合上—交</p>
<p>$\bigcap\limits_{i=1}^{n}=A_1\cap A_2…\cap A_n$</p>
<h5 id="3、证明方法"><a href="#3、证明方法" class="headerlink" title="3、证明方法"></a>3、证明方法</h5><p>1)直接证明法</p>
<p>2)归谬法（反证法）</p>
<p>3)数学归纳法</p>
<h5 id="4、递归"><a href="#4、递归" class="headerlink" title="4、递归"></a>4、递归</h5><p>用自身定义自身</p>
<h3 id="第2章-命题逻辑"><a href="#第2章-命题逻辑" class="headerlink" title="第2章 命题逻辑"></a>第2章 命题逻辑</h3><h5 id="1、命题逻辑基本概念"><a href="#1、命题逻辑基本概念" class="headerlink" title="1、命题逻辑基本概念"></a>1、命题逻辑基本概念</h5><p>1)命题与联结词</p>
<p>简单命题—简单的陈述句</p>
<p>复合命题—由简单命题通过联结词的联结而成的陈述句</p>
<p>$\neg p$：非$p$ 。（否定联结词）</p>
<p>$p\wedge q$：$p$并且$q$。（合取联结词）</p>
<p>$p\vee q$：$p$或$q$。（析取联结词）—自然语言中“或”具有二义性，相容性或排斥性（<strong>相容或</strong>、<strong>排斥或</strong>）</p>
<p>$p\to q$：如果$p$，则$q$。（蕴含联结词）</p>
<p>$p\leftrightarrow q$：$p$当且仅当$q$。（等价联结词）</p>
<p><strong>基本复合命题：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">p    q</th>
<th>$\neg p$</th>
<th>$p\wedge q$</th>
<th>$p\vee q$</th>
<th>$p\to q$</th>
<th>$p\leftrightarrow q$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0    0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center">0    1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">1    0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center">1    1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
<p>多次使用联结词集中的联结词，可以组成更为复杂的复杂命题。</p>
<h5 id="2、命题逻辑等值演算"><a href="#2、命题逻辑等值演算" class="headerlink" title="2、命题逻辑等值演算"></a>2、命题逻辑等值演算</h5><p>基本的等值式</p>
<p>1）幂等律</p>
<p>2)交换律</p>
<p>3)结合律</p>
<p>4)分配律</p>
<p>5)德摩根律</p>
<p>6)吸收律</p>
<p>7)零律</p>
<p>8)同一律</p>
<p>9)排中律</p>
<p>10)矛盾律</p>
<p>（对偶原理：$\vee-\wedge$互换，0-1互换）</p>
<p>11)双重否定律</p>
<p>12)蕴含等值式</p>
<p>13)等价等值式</p>
<p>14)等价否定等值式</p>
<p>15)假言易位</p>
<p>16)归谬论</p>
<p>等值演算(例子)</p>
<p>$p\to q \Leftrightarrow \neg p \vee q$ </p>
<h5 id="3、范式"><a href="#3、范式" class="headerlink" title="3、范式"></a>3、范式</h5><p>析取范式、合取范式—统称为范式</p>
<h5 id="4、推理"><a href="#4、推理" class="headerlink" title="4、推理"></a>4、推理</h5><p>(1)推理的形式结构</p>
<p>​                                           $(A_1\wedge A_2\wedge …\wedge A_k)\to B$</p>
<p>前提：$A_1,A_2…A_k$</p>
<p>结论：$B$</p>
<p>(2)重要的推理定律</p>
<p>1)附加律</p>
<p>2)化简律</p>
<p>3)假言推理</p>
<p>4)拒取式</p>
<p>5)析取三段论</p>
<p>6)假言三段论</p>
<p>7)等价三段论</p>
<p>8)构造性两难</p>
<h3 id="第3章-一阶逻辑"><a href="#第3章-一阶逻辑" class="headerlink" title="第3章 一阶逻辑"></a>第3章 一阶逻辑</h3><h5 id="1、一阶逻辑基本概念"><a href="#1、一阶逻辑基本概念" class="headerlink" title="1、一阶逻辑基本概念"></a>1、一阶逻辑基本概念</h5><p><strong>个体</strong>：所研究对象中可以独立存在的具体或抽象的客体</p>
<p><strong>谓词</strong>：刻画个体性质以及个体之间相互关系</p>
<p><strong>量词</strong>：表示数量的词（全称量词、存在量词）</p>
<p><strong>$\to$ 命题符号化</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/08/21/差分隐私基本算法代码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/21/差分隐私基本算法代码/" itemprop="url">差分隐私基本算法代码</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-21T09:57:42+08:00">
                2019-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/08/20/差分隐私论文-中文-基于差分隐私的学术成绩隐私保护系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/差分隐私论文-中文-基于差分隐私的学术成绩隐私保护系统/" itemprop="url">差分隐私论文(中文)|基于差分隐私的学术成绩隐私保护系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-20T09:48:45+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>论文地址：<a href="https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2018&amp;filename=WHZG201705008&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0pmNExoNUdFbU9VN1RHM1dDUC85YzBuZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDMzMTZiSVI4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUkxPZmIrUnZGaURuVkwvSk1pWFJhYkc0SDliTXFvOUY=" target="_blank" rel="noopener">https://kns.cnki.net/KCMS/detail/detail.aspx?dbcode=CJFQ&amp;dbname=CJFDLAST2018&amp;filename=WHZG201705008&amp;uid=WEEvREcwSlJHSldRa1Fhb09jT0pmNExoNUdFbU9VN1RHM1dDUC85YzBuZz0=$9A4hF_YAuvQ5obgVAqNKPCYcEjKensW4IQMovwHtwkF4VYPoHbKxJw!!&amp;v=MDMzMTZiSVI4ZVgxTHV4WVM3RGgxVDNxVHJXTTFGckNVUkxPZmIrUnZGaURuVkwvSk1pWFJhYkc0SDliTXFvOUY=</a></p>
<h4 id="一、摘要"><a href="#一、摘要" class="headerlink" title="一、摘要"></a>一、摘要</h4><p>基于学生成绩的数据挖掘技术出现了许多创新,设计了一个基于差分隐私技术的学生成绩隐私保护系统,该系统从考虑保护学生成绩隐私角度出发,在发布学生成绩数据前,先对静态数据进行差分隐私保护处理,再将数据应用到真实教育数据发布中,最终不仅方便用户根据不同需求发布结果,而且达到对学生的个人隐私数据进行保护的目的。</p>
<h4 id="二、系统框架"><a href="#二、系统框架" class="headerlink" title="二、系统框架"></a>二、系统框架</h4><p><img src="/2019/08/20/差分隐私论文-中文-基于差分隐私的学术成绩隐私保护系统/1.png" alt></p>
<h4 id="三、算法实现"><a href="#三、算法实现" class="headerlink" title="三、算法实现"></a>三、算法实现</h4><p>差分隐私主要机制有两种：：</p>
<p>1）对于数值类型结果加噪的拉普拉斯机制；</p>
<p>2）对非数值类型结果加噪的指数机制。</p>
<p>例如：学生成绩一般可以分为两种类型数据：数值型（分值 0 到 100）和非数值型（等级 A 到 F）。对于数值型查询结果，一般会在发布数据前对查询结果采用拉普拉斯机制进行加噪；对于非数值类型查询结果，一般会在发布数据前对查询结果采用指数机制进行加噪。</p>
<p>算法流程：</p>
<p><img src="/2019/08/20/差分隐私论文-中文-基于差分隐私的学术成绩隐私保护系统/2.png" alt></p>
<h4 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h4><p><img src="/2019/08/20/差分隐私论文-中文-基于差分隐私的学术成绩隐私保护系统/3.jpg" alt></p>
<p>当ε = 0. 1 时，生成的成绩统 计结果相对误差为 0.113；当ε = 0. 5 时，生成的成绩统计结果相对误差为 0. 046；当ε = 0. 9 时，生成的成 绩统计结果相对误差为 0. 014。总之，ε 越大，加入随机噪声越小，隐私保护安全性越弱。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://Leselier.github.io/2019/08/20/全栈刷题之路-（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Leselier">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/abc.JPG">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Leselier's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/20/全栈刷题之路-（一）/" itemprop="url">全栈刷题之路|（一）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-20T09:04:31+08:00">
                2019-08-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1、<strong>如何实现一个高效的单向链表逆序输出？</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> data;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;node;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">create</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	node* head=(node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">	head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	node* pre = head;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">		node* q = (node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">		pre-&gt;next = q;</span><br><span class="line">		q-&gt;data = a[i];</span><br><span class="line">		pre-&gt;next = q;</span><br><span class="line">		pre = q;</span><br><span class="line">	&#125;</span><br><span class="line">	pre-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">(node* head)</span> </span>&#123;</span><br><span class="line">	node* q = head;</span><br><span class="line">	<span class="keyword">while</span> (q-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		q = q-&gt;next;</span><br><span class="line">		<span class="built_in">cout</span> &lt;&lt; q-&gt;data;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(node* head)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	node* pre = <span class="literal">NULL</span>;</span><br><span class="line">	node* cur = head-&gt;next;</span><br><span class="line">	node* next;</span><br><span class="line">	<span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (cur-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			cur-&gt;next = pre;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		next = cur-&gt;next;</span><br><span class="line">		cur-&gt;next = pre;</span><br><span class="line">		pre = cur;</span><br><span class="line">		cur = next;</span><br><span class="line">	&#125;</span><br><span class="line">	head-&gt;next = cur;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">		<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">	node* head = create(a, <span class="number">5</span>);</span><br><span class="line">	Print(head);</span><br><span class="line">	reverse(head);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Print(head);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、<strong>已知sqrt(2)约等于1.414，要求不用数学库，求sqrt(2)精确到小数点后10位</strong></p>
<p>①二分法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="number">0.0000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt_2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">double</span> low = <span class="number">1.41</span>, high = <span class="number">1.42</span>;</span><br><span class="line">	<span class="keyword">double</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">while</span> (high - low &gt; E) &#123;</span><br><span class="line">		<span class="keyword">if</span> (mid * mid &gt; <span class="number">2</span>)</span><br><span class="line">			high = mid;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			low = mid;</span><br><span class="line">		mid = (high + low) / <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> mid;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sqrt_2();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>②牛顿迭代逼近法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> E = <span class="number">0.0000000001</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">sqrt_fun</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当n&gt;=1时，从n开始迭代，否则从1开始迭代</span></span><br><span class="line">	<span class="keyword">double</span> res = n &gt; <span class="number">1</span> ? n : <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span> (res * res - n &gt; E)</span><br><span class="line">		res = <span class="number">0.5</span> * (res + n / res);</span><br><span class="line">	<span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; sqrt_fun(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3、<strong>给定一个二叉搜索树(BST)，找到树中第 K 小的节点</strong></p>
<p>树相关的题目，第一眼就想到递归求解，左右子树分别遍历。联想到二叉搜索树的性质，root 大于左子树，小于右子树，如果左子树的节点数目等于 K-1，那么 root 就是结果，否则如果左子树节点数目小于 K-1，那么结果必然在右子树，否则就在左子树。因此在搜索的时候同时返回节点数目，跟 K 做对比，就能得出结果了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">boolean</span> found;  <span class="comment">// 是否找到</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> val;  <span class="comment">// 节点数目</span></span><br><span class="line">        ResultType(<span class="keyword">boolean</span> found, <span class="keyword">int</span> val) &#123;</span><br><span class="line">            <span class="keyword">this</span>.found = found;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> kthSmallestHelper(root, k).val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ResultType <span class="title">kthSmallestHelper</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ResultType left = kthSmallestHelper(root.left, k);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树找到，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (left.found) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>, left.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 左子树的节点数目 = K-1，结果为 root 的值</span></span><br><span class="line">        <span class="keyword">if</span> (k - left.val == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>, root.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 右子树寻找</span></span><br><span class="line">        ResultType right = kthSmallestHelper(root.right, k - left.val - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (right.found) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">true</span>, right.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到，返回节点总数</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">false</span>, left.val + <span class="number">1</span> + right.val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4、<strong>LRU缓存机制</strong>（缺）</p>
<p>LRU（最近最少使用算法）——一种简单的缓存策略</p>
<p>5、<strong>关于epoll和select的区别</strong>（缺）</p>
<p>6、</p>
<p>7、</p>
<p>8、</p>
<p>9、 <strong>输入 ping IP 后敲回车，发包前会发生什么？</strong></p>
<p>首先根据目的IP和路由表决定走哪个网卡，再根据网卡的子网掩码地址判断目的IP是否在子网内。如果不在则会通过ARP缓存查询IP的网卡地址，不存在的话会通过广播询问目的IP的mac地址，得到后就开始发包了，同时mac地址也会被arp缓存起来。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/abc.JPG" alt="Leselier">
            
              <p class="site-author-name" itemprop="name">Leselier</p>
              <p class="site-description motion-element" itemprop="description">A master student of JUN</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">31</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Leselier" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/5708446219/home" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leselier</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end --></body>
</html>
